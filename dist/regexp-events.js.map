{"version":3,"file":"regexp-events.js","sources":["../src/Event.js","../src/utils.js","../src/Emitter.js"],"sourcesContent":["/**\n * @classdesc the basic event class\n * @class Event\n */\nexport default class Event {\n\t/**\n\t * @param  {String} type - the type of event, this can be anything, but its a good idea just to make it a string\n\t * @param  {Emitter} target - the emitter that is firing this event\n\t * @param  {Array} args - an array of arguments that is used on the listener functions\n\t * @return {Event}\n\t */\n\tconstructor(type, args, target) {\n\t\tif (typeof type !== \"string\") throw new Error(\"Event.type has to be a string\");\n\n\t\t/**\n\t\t * the type of event\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * an array of arguments that are used when calling the listener function\n\t\t * @type {Array}\n\t\t */\n\t\tthis.args = args || [];\n\n\t\t/**\n\t\t * a reference to the emitter that fired the event\n\t\t * @type {Emitter}\n\t\t */\n\t\tthis.target = target;\n\t}\n}\n","export function clearListeners(eventMap, eventType, force) {\n\tif (force) {\n\t\teventMap.delete(eventType);\n\t} else {\n\t\tlet listeners = eventMap.get(eventType);\n\t\tlisteners.filter(listener => !listener.isStatic).forEach((listener, i) => {\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t});\n\n\t\t// if there are not listeners left, remove the array\n\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t}\n}\n\nexport function isRegExpEqual(r1, r2) {\n\treturn (\n\t\tr1 instanceof RegExp &&\n\t\tr2 instanceof RegExp &&\n\t\tr2.source === r1.source &&\n\t\tr2.global === r1.global &&\n\t\tr2.ignoreCase === r1.ignoreCase &&\n\t\tr2.multiline === r1.multiline &&\n\t\tr2.sticky === r1.sticky &&\n\t\tr2.unicode === r1.unicode\n\t);\n}\n","import Event from \"./Event\";\nimport { clearListeners, isRegExpEqual } from \"./utils\";\n\nfunction isBoolean(v) {\n\treturn v === true || v === false;\n}\n\nfunction findInArgArray(args, fn, start, df) {\n\tfor (let i = 0; i < args.length - start; i++) if (fn(args[start + i])) return args[start + i];\n\n\treturn df;\n}\n\n/**\n * a simple event emitter\n */\nexport default class Emitter {\n\tconstructor() {\n\t\t/**\n\t\t * whether to suppress all events on this emitter\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.suppressEvents = false;\n\t}\n\n\t/**\n\t * returns the Map that is used to store events for emitters\n\t * @param {Emitter} emitter\n\t * @return {WeakMap}\n\t */\n\tstatic getEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\treturn map.get(emitter);\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic createEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tlet events = new Map();\n\t\tmap.set(emitter, events);\n\t\treturn events;\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic removeEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tif (map.has(emitter)) map.delete(emitter);\n\t}\n\n\t/**\n\t * returns the Map used to store events\n\t * @return {Map}\n\t */\n\tget eventMap() {\n\t\treturn Emitter.getEventMap(this);\n\t}\n\n\t/**\n\t * listens for an event of this emitter\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - the function to be called when the event fires\n\t * @param  {Object|Boolean|Number} [context] - the context to run the function under\n\t * @param  {Boolean|Number|Object} [isStatic=true] - whether this listener can be removed without force\n\t * @param  {Number|Boolean|Object} [times=Infinity] the times this listener can be called before it removes it self\n\t * @return {this}\n\t */\n\ton(eventType, listener, context, isStatic, times) {\n\t\tif (typeof eventType !== \"string\" && !(eventType instanceof RegExp) && !(eventType instanceof Event))\n\t\t\tthrow new Error(\"Emitter.on requires a String, Event or RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.on requires a function as the second argument\");\n\n\t\tisStatic = findInArgArray(arguments, isBoolean, 2, false);\n\t\ttimes = findInArgArray(arguments, n => Number.isFinite(n) || n === Infinity, 2, Infinity);\n\t\tcontext = findInArgArray(\n\t\t\targuments,\n\t\t\to => {\n\t\t\t\treturn typeof o === \"object\";\n\t\t\t},\n\t\t\t2,\n\t\t\tundefined,\n\t\t);\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) eventMap = Emitter.createEventMap(this);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\t// add the listener to the array\n\t\teventMap.get(eventType).push({\n\t\t\tfunc: listener,\n\t\t\tctx: context,\n\t\t\ttimes: times,\n\t\t\tisStatic: isStatic,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * binds a listener that removes its self once the event is fired\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener\n\t * @param  {Object|Boolean} [context] - the context to run the functions under\n\t * @param  {Boolean|Object} [isStatic = false] - whether this listener can be removed without using force\n\t * @return {this}\n\t */\n\tonce(eventType, listener, context, isStatic) {\n\t\treturn this.on(eventType, listener, 1, context, isStatic);\n\t}\n\n\t/**\n\t * removes a listener\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - this has to be the exact function that was bound\n\t * @param  {*|Boolean} [context] - this has to be the exact context that was bound with the listener\n\t * @param  {Boolean} [force=false] - whether to force remove the listeners\n\t * @return {this}\n\t */\n\toff(eventType, listener, context, force) {\n\t\tif (eventType == null) throw new Error(\"Emitter.off requires a String or a RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.off requires a function as the second argument\");\n\n\t\tforce = findInArgArray(arguments, isBoolean, 2, false);\n\t\tcontext = findInArgArray(arguments, o => typeof o === \"object\", 2, undefined);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) return this; // if there is not event map, just exit\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tlet listeners = eventMap.get(eventType);\n\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\tif (listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic ? force : true))\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t});\n\n\t\t\t// remove the listener array if there are no listeners left\n\t\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\t// if the regexp flags and source match then remove the listeners\n\t\t\t\tif (listenersEventType instanceof RegExp && isRegExpEqual(eventType, listenersEventType)) {\n\t\t\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tlistenerData.func === listener &&\n\t\t\t\t\t\t\tlistenerData.ctx === context &&\n\t\t\t\t\t\t\t(listenerData.isStatic ? force : true)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\t// remove the listener array if there are no listeners left\n\t\t\t\t\tif (listeners.length === 0) eventMap.delete(listenersEventType);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * fires ad event on this emitter\n\t * @param {String|Event} eventType\n\t * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in\n\t * @return {this}\n\t */\n\temit(eventType, ...args) {\n\t\tif (this.suppressEvents) return;\n\t\tlet eventMap = this.eventMap;\n\t\tlet event;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\t// if its an event use the events type\n\t\tif (eventType instanceof Event) {\n\t\t\tevent = eventType;\n\n\t\t\t// if the event dose not have a target set it to this emitter\n\t\t\tif (event.target === undefined) event.target = this;\n\t\t} else if (typeof eventType === \"string\") event = new Event(eventType, args, this);\n\t\telse throw new Error(\"Emitter.emit requires a String or Event as the first argument\");\n\n\t\tlet listenerArgs = Array.from(event.args).concat([event]);\n\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\tif (\n\t\t\t\t// if they are both strings and they match\n\t\t\t\t(typeof event.type === \"string\" && listenersEventType === event.type) ||\n\t\t\t\t// if the listenersEventType is a RegExp and the event type is a string, see if they match\n\t\t\t\t(typeof event.type === \"string\" &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tlistenersEventType.test(event.type)) ||\n\t\t\t\t// if they are both RegExp see if they match\n\t\t\t\t(event.type instanceof RegExp &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tisRegExpEqual(listenersEventType, event.type))\n\t\t\t) {\n\t\t\t\tlisteners.forEach(listener => {\n\t\t\t\t\tlistener.func.apply(listener.ctx, listenerArgs);\n\t\t\t\t\tif (--listener.times <= 0) this.off(event.type, listener.func, listener.ctx, true);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * removes all events of \"eventType\"\n\t * NOTE: passing no arguments will clean all listeners\n\t * NOTE: passing a single boolean will clear all listens and act as the force flag\n\t * @param {RegExp|String|Event|Boolean} [eventType] - the type of event\n\t * @param {Boolean} [force = false] - whether to force remove the listeners\n\t * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types\n\t * @return {this}\n\t */\n\tclear(eventType, force = false, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is no event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tclearListeners(eventMap, eventType, force);\n\t\t} else if (eventType instanceof Event) {\n\t\t\tclearListeners(eventMap, eventType.type, force);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tArray.from(eventMap)\n\t\t\t\t.map(a => a[0])\n\t\t\t\t.forEach(listenersEventType => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclearListeners(eventMap, listenersEventType, force);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t} else if (arguments.length === 1 && eventType === true) {\n\t\t\t// remove all listeners\n\t\t\teventMap.clear();\n\t\t} else if ((eventType === false || eventType === undefined) && arguments.length <= 1) {\n\t\t\t// remove all listeners that are not static\n\t\t\teventMap.forEach((listeners, type) => {\n\t\t\t\tlisteners.filter(listener => !listener.isStatic).forEach(listener => {\n\t\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t\t\t});\n\n\t\t\t\t// if there are no listeners left, remove the array\n\t\t\t\tif (listeners.length === 0) eventMap.delete(type);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * returns the number of listeners bound to the event\n\t * @param  {RegExp|String|Event} [eventType]\n\t * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types\n\t * @return {Boolean}\n\t */\n\tcount(eventType, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return 0;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\treturn eventMap.has(eventType) ? eventMap.get(eventType).length : 0;\n\t\t} else if (eventType instanceof Event) {\n\t\t\treturn eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\tif (\n\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t) {\n\t\t\t\t\ttotal += listeners.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn total;\n\t\t} else {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach(listeners => {\n\t\t\t\ttotal += listeners.length;\n\t\t\t});\n\t\t\treturn total;\n\t\t}\n\t}\n\n\t/**\n\t * cleans up the emitter for GC\n\t */\n\tdispose() {\n\t\tEmitter.removeEventMap(this);\n\t\treturn this;\n\t}\n}\n"],"names":["Event","type","args","target","Error","clearListeners","eventMap","eventType","force","delete","listeners","get","filter","listener","isStatic","forEach","i","splice","indexOf","length","isRegExpEqual","r1","r2","RegExp","source","global","ignoreCase","multiline","sticky","unicode","isBoolean","v","findInArgArray","fn","start","df","Emitter","suppressEvents","context","times","arguments","Number","isFinite","n","Infinity","o","undefined","createEventMap","has","set","push","on","listenerData","func","ctx","listenersEventType","event","listenerArgs","Array","from","concat","test","apply","off","useRegExp","map","a","clear","total","removeEventMap","getEventMap","emitter","events","WeakMap","Map"],"mappings":"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"}