{"version":3,"file":"regexp-events.umd.min.js","sources":["../src/utils.js","../node_modules/lodash.isstring/index.js","../node_modules/lodash.isfunction/index.js","../node_modules/lodash.isnil/index.js","../src/Event.js","../node_modules/lodash.isregexp/index.js","../src/Emitter.js"],"sourcesContent":["export function clearListeners(eventMap, eventType, force){\r\n\tif(force)\r\n\t\teventMap.delete(eventType);\r\n\telse{\r\n\t\tlet listeners = eventMap.get(eventType);\r\n\t\tlisteners.filter(listener => listener.removable).forEach((listener, i) => {\r\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\r\n\t\t});\r\n\r\n\t\t// if there are not listeners left, remove the array\r\n\t\tif(listeners.length === 0)\r\n\t\t\teventMap.delete(eventType);\r\n\t}\r\n}\r\n\r\nexport function isRegExpEqual(r1, r2){\r\n\treturn (\r\n\t\tr1 instanceof RegExp &&\r\n\t\tr2 instanceof RegExp &&\r\n\t\tr2.source === r1.source &&\r\n\t\tr2.global === r1.global &&\r\n\t\tr2.ignoreCase === r1.ignoreCase &&\r\n\t\tr2.multiline === r1.multiline &&\r\n\t\tr2.sticky === r1.sticky &&\r\n\t\tr2.unicode === r1.unicode\r\n\t);\r\n}","/**\n * lodash 4.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @type Function\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n}\n\nmodule.exports = isString;\n","/**\n * lodash 3.0.8 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8 which returns 'object' for typed array constructors, and\n  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isFunction;\n","/**\n * lodash 4.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n","/**\r\n * @classdesc the basic event class\r\n * @class Event\r\n */\r\nexport default class Event{\r\n\t/**\r\n\t * @param  {String} type - the type of event, this can be anything, but its a good idea just to make it a string\r\n\t * @param  {Emitter} target - the emitter that is firing this event\r\n\t * @param  {Array} data - an array of arguments that is used on the listener functions\r\n\t * @return {Event}\r\n\t */\r\n\tconstructor(type, target, data){\r\n\t\t/**\r\n\t\t * the type of event\r\n\t\t * @type {String}\r\n\t\t */\r\n\t\tthis.type = type;\r\n\r\n\t\t/**\r\n\t\t * a reference to the emitter that fired the event\r\n\t\t * @type {Emitter}\r\n\t\t */\r\n\t\tthis.target = target;\r\n\r\n\t\t/**\r\n\t\t * an array of arguments that are used when calling the listener function\r\n\t\t * @type {Array}\r\n\t\t */\r\n\t\tthis.data = data;\r\n\t}\r\n}\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObject(value) && objectToString.call(value) == regexpTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n","import Event from './Event';\r\nimport {clearListeners, isRegExpEqual} from './utils';\r\nimport isString from 'lodash.isstring';\r\nimport isFunction from 'lodash.isfunction';\r\nimport isNil from 'lodash.isnil';\r\nimport isRegExp from 'lodash.isregexp';\r\n\r\n/**\r\n * a simple event emitter\r\n */\r\nexport default class Emitter{\r\n\tconstructor(){\r\n\t\t/**\r\n\t\t * whether to suppress all events on this emitter\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\t\tthis.suppressEvents = false;\r\n\t}\r\n\r\n\t/**\r\n\t * returns the Map that is used to store events for emitters\r\n\t * @param {Emitter} emitter\r\n\t * @return {WeakMap}\r\n\t */\r\n\tstatic getEventMap(emitter){\r\n\t\tlet map = this.events || (this.events = new WeakMap());\r\n\t\treturn map.get(emitter);\r\n\t}\r\n\r\n\t/**\r\n\t * creates a new Map for the emitter\r\n\t * @param {Emitter} emitter\r\n\t * @return {WeakMap}\r\n\t */\r\n\tstatic createEventMap(emitter){\r\n\t\tlet map = this.events || (this.events = new WeakMap());\r\n\t\tlet events = new Map();\r\n\t\tmap.set(emitter, events);\r\n\t\treturn events;\r\n\t}\r\n\r\n\t/**\r\n\t * returns the Map used to store events\r\n\t * @return {Map}\r\n\t */\r\n\tget eventMap() {\r\n\t\treturn Emitter.getEventMap(this);\r\n\t}\r\n\r\n\t/**\r\n\t * listens for an event of this emitter\r\n\t * @param  {RegExp|String|Event} type\r\n\t * @param  {Function} func - the function to be called when the event fires\r\n\t * @param  {*} [ctx] - the context to run the function under\r\n\t * @param  {Boolean} [removable=true] - whether this listener can be removed without force\r\n\t * @return {this}\r\n\t */\r\n\ton(type, func, ctx, removable = true){\r\n\t\tif(isNil(type))\r\n\t\t\tthrow new Error('Emitter.on requires a String or a RegExp as the first argument');\r\n\r\n\t\tif(!isFunction(func))\r\n\t\t\tthrow new Error('Emitter.on requires a function as the second argument');\r\n\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tif(!eventMap)\r\n\t\t\teventMap = Emitter.createEventMap(this);\r\n\r\n\t\tif(type instanceof Event)\r\n\t\t\ttype = type.type;\r\n\r\n\t\tif(!eventMap.has(type))\r\n\t\t\teventMap.set(type, []);\r\n\r\n\t\teventMap.get(type).push({\r\n\t\t\tfunc: func,\r\n\t\t\tctx: ctx,\r\n\t\t\tonce: false,\r\n\t\t\tremovable: removable\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * binds a listener that removes its self once the event is fired\r\n\t * @param  {RegExp|String|Event} type\r\n\t * @param  {Function} func\r\n\t * @param  {*} [ctx] - the context to run the functions under\r\n\t * @return {this}\r\n\t *\r\n\t * TODO: make once() accept a \"removable\" flag\r\n\t */\r\n\tonce(type, func, ctx){\r\n\t\tif(isNil(type))\r\n\t\t\tthrow new Error('Emitter.once requires a String or a RegExp as the first argument');\r\n\r\n\t\tif(!isFunction(func))\r\n\t\t\tthrow new Error('Emitter.once requires a function as the second argument');\r\n\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tif(!eventMap)\r\n\t\t\teventMap = Emitter.createEventMap(this);\r\n\r\n\t\tif(type instanceof Event)\r\n\t\t\ttype = type.type;\r\n\r\n\t\tif(!eventMap.has(type))\r\n\t\t\teventMap.set(type, []);\r\n\r\n\t\teventMap.get(type).push({\r\n\t\t\tfunc: func,\r\n\t\t\tctx: ctx,\r\n\t\t\tonce: true,\r\n\t\t\tremovable: true\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * removes a listener\r\n\t * NOTE: this dose not take a \"force\" flag, since to remove a listener through this method you have to provide the exact type, function, and ctx\r\n\t * @param  {RegExp|String|Event} type\r\n\t * @param  {Function} func - this has to be the exact function that was bound\r\n\t * @param  {*} [ctx] - this has to be the exact context that was bound with the listener\r\n\t * @return {this}\r\n\t *\r\n\t * TODO add force flag to Emitter.off\r\n\t */\r\n\toff(type, func, ctx){\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tlet eventType = type;\r\n\r\n\t\t// if there is not event map, just exit\r\n\t\tif(!eventMap)\r\n\t\t\treturn this;\r\n\r\n\t\tif(eventType instanceof Event)\r\n\t\t\teventType = eventType.type;\r\n\r\n\t\tif(!eventMap.has(eventType))\r\n\t\t\teventMap.set(eventType, []);\r\n\r\n\t\tif(isString(eventType)){\r\n\t\t\tlet listeners = eventMap.get(eventType);\r\n\t\t\tlisteners.forEach((listener, i) => {\r\n\t\t\t\t// done bother about force in this situation, because the user provied the exact type, function, and ctx\r\n\t\t\t\tif(listener.func === func && ctx === listener.ctx)\r\n\t\t\t\t\tlisteners.splice(i,1);\r\n\t\t\t});\r\n\r\n\t\t\t// remove the listener array if there are no listeners left\r\n\t\t\tif(listeners.length === 0)\r\n\t\t\t\teventMap.delete(eventType);\r\n\t\t}\r\n\t\telse if(isRegExp(eventType)){\r\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\r\n\t\t\t\t// if the regexp flags and source match then remove the listeners\r\n\t\t\t\tif(isRegExp(listenersEventType) && isRegExpEqual(eventType, listenersEventType)){\r\n\t\t\t\t\tlisteners.forEach((listener, i) => {\r\n\t\t\t\t\t\tif(listener.func === func && ctx === listener.ctx)\r\n\t\t\t\t\t\t\tlisteners.splice(i,1);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// remove the listener array if there are no listeners left\r\n\t\t\t\t\tif(listeners.length === 0)\r\n\t\t\t\t\t\teventMap.delete(listenersEventType);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * fires ad event on this emitter\r\n\t * @param {String|Event} type\r\n\t * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in\r\n\t * @return {this}\r\n\t */\r\n\temit(type, ...args){\r\n\t\tif(this.suppressEvents) return;\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tlet event;\r\n\r\n\t\t// if there is not event map, just exit\r\n\t\tif(!eventMap)\r\n\t\t\treturn this;\r\n\r\n\t\t// if its an event use the events type\r\n\t\tif(type instanceof Event)\r\n\t\t\tevent = type;\r\n\t\telse\r\n\t\t\tevent = new Event(type, this, args);\r\n\r\n\t\tlet listenerArgs = Array.from(event.data || args).concat([event]);\r\n\t\teventMap.forEach((listeners, listenersEventType) => {\r\n\t\t\tif(\r\n\t\t\t\t// if they are both strings and they match\r\n\t\t\t\t(isString(event.type) && listenersEventType === event.type) ||\r\n\t\t\t\t// if the listenersEventType is a RegExp and the event type is a string, see if they match\r\n\t\t\t\t(isString(event.type) && isRegExp(listenersEventType) && listenersEventType.test(event.type)) ||\r\n\t\t\t\t// if they are both RegExp see if they match\r\n\t\t\t\t(isRegExp(event.type) && isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, event.type))\r\n\t\t\t){\r\n\t\t\t\tlisteners.forEach(listener => {\r\n\t\t\t\t\tlistener.func.apply(listener.ctx, listenerArgs);\r\n\t\t\t\t\tif(listener.once)\r\n\t\t\t\t\t\tthis.off(event.type, listener.func, listener.ctx, true);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * removes all events of \"type\"\r\n\t * NOTE: passing no arguments will clean all listeners\r\n\t * NOTE: passing a single boolean will clear all listens and act as the force flag\r\n\t * @param {RegExp|String|Event|Boolean} [type] - the type of event\r\n\t * @param {Boolean} [force = false] - whether to force remove the listeners\r\n\t * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types\r\n\t * @return {this}\r\n\t */\r\n\tclear(type, force = false, useRegExp = true){\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tlet eventType = type;\r\n\r\n\t\t// if there is not event map, just exit\r\n\t\tif(!eventMap)\r\n\t\t\treturn this;\r\n\r\n\t\tif(isString(eventType)){\r\n\t\t\tclearListeners(eventMap, eventType, force);\r\n\t\t}\r\n\t\telse if(eventType instanceof Event){\r\n\t\t\tthis.clear(eventType.type, useRegExp, force);\r\n\t\t}\r\n\t\telse if(isRegExp(eventType)){\r\n\t\t\tArray.from(eventMap).map(a => a[0]).forEach(listenersEventType => {\r\n\t\t\t\tif(\r\n\t\t\t\t\t// if the string matches the regex\r\n\t\t\t\t\t(isString(listenersEventType) && useRegExp && eventType.test(listenersEventType)) ||\r\n\t\t\t\t\t// if the regex(s) match\r\n\t\t\t\t\t(isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, eventType))\r\n\t\t\t\t){\r\n\t\t\t\t\tclearListeners(eventMap, listenersEventType, force);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\telse if(arguments.length === 1 && eventType === true){\r\n\t\t\teventMap.clear();\r\n\t\t}\r\n\t\telse if(eventType === false || eventType === undefined && arguments.length <= 1){\r\n\t\t\teventMap.forEach((listeners, type) => {\r\n\t\t\t\tlisteners.filter(listener => listener.removable).forEach(listener => {\r\n\t\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// if there are no listeners left, remove the array\r\n\t\t\t\tif(listeners.length === 0)\r\n\t\t\t\t\teventMap.delete(type);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * returns the number of listeners bound to the event\r\n\t * @param  {RegExp|String|Event} [type]\r\n\t * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types\r\n\t * @return {Boolean}\r\n\t */\r\n\tcount(type, useRegExp = true){\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tlet eventType = type;\r\n\r\n\t\t// if there is not event map, just exit\r\n\t\tif(!eventMap)\r\n\t\t\treturn 0;\r\n\r\n\t\tif(isString(eventType)){\r\n\t\t\treturn eventMap.has(eventType) ? eventMap.get(eventType).length : 0;\r\n\t\t}\r\n\t\telse if(eventType instanceof Event){\r\n\t\t\treturn eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;\r\n\t\t}\r\n\t\telse if(isRegExp(eventType)){\r\n\t\t\tlet total = 0;\r\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\r\n\t\t\t\tif(isString(listenersEventType) && useRegExp && eventType.test(listenersEventType))\r\n\t\t\t\t\ttotal += listeners.length;\r\n\t\t\t\telse if(isRegExpEqual(listenersEventType, eventType))\r\n\t\t\t\t\ttotal += listeners.length;\r\n\t\t\t});\r\n\t\t\treturn total;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tlet total = 0;\r\n\t\t\teventMap.forEach((listeners, eventType) => {\r\n\t\t\t\ttotal += listeners.length;\r\n\t\t\t});\r\n\t\t\treturn total;\r\n\t\t}\r\n\t}\r\n}\r\n"],"names":["clearListeners","eventMap","eventType","force","delete","listeners","get","filter","listener","removable","forEach","i","splice","indexOf","length","isRegExpEqual","r1","r2","RegExp","source","global","ignoreCase","multiline","sticky","unicode","isObjectLike","value","isString","isArray","objectToString","call","stringTag","isFunction","tag","isObject","funcTag","genTag","type","isNil","Event","target","data","objectProto","Object","prototype","toString","Array","baseIsRegExp","regexpTag","freeGlobal","freeExports","exports","nodeType","freeModule","module","moduleExports","freeProcess","process","nodeUtil","binding","e","nodeIsRegExp","isRegExp","func","Emitter","suppressEvents","ctx","Error","this","createEventMap","has","set","push","listenersEventType","event","args","listenerArgs","from","concat","test","apply","once","_this","off","useRegExp","clear","map","a","arguments","undefined","total","getEventMap","emitter","events","WeakMap","Map"],"mappings":";8NAAO,SAASA,GAAeC,EAAUC,EAAWC,MAChDA,EACFF,EAASG,OAAOF,OACb,IACCG,GAAYJ,EAASK,IAAIJ,KACnBK,OAAO,kBAAYC,GAASC,YAAWC,QAAQ,SAACF,EAAUG,KACzDC,OAAOP,EAAUQ,QAAQL,GAAW,KAIvB,IAArBH,EAAUS,QACZb,EAASG,OAAOF,IAInB,QAAgBa,GAAcC,EAAIC,SAEhCD,aAAcE,SACdD,YAAcC,SACdD,EAAGE,SAAWH,EAAGG,QACjBF,EAAGG,SAAWJ,EAAGI,QACjBH,EAAGI,aAAeL,EAAGK,YACrBJ,EAAGK,YAAcN,EAAGM,WACpBL,EAAGM,SAAWP,EAAGO,QACjBN,EAAGO,UAAYR,EAAGQ,QC6CpB,QAASC,GAAaC,GACpB,QAASA,GAAyB,gBAATA,GAmB3B,QAASC,GAASD,GAChB,MAAuB,gBAATA,KACVE,EAAQF,IAAUD,EAAaC,IAAUG,EAAeC,KAAKJ,IAAUK,ECrD7E,QAASC,GAAWN,GAIlB,GAAIO,GAAMC,EAASR,GAASG,EAAeC,KAAKJ,GAAS,EACzD,OAAOO,IAAOE,GAAWF,GAAOG,EA0BlC,QAASF,GAASR,GAChB,GAAIW,SAAcX,EAClB,SAASA,IAAkB,UAARW,GAA4B,YAARA,GC3CzC,QAASC,GAAMZ,GACb,MAAgB,OAATA,0VCzBYa,EAOpB,WAAYF,EAAMG,EAAQC,kBAKpBJ,KAAOA,OAMPG,OAASA,OAMTC,KAAOA,GHlBVV,EAAY,kBAGZW,EAAcC,OAAOC,UAMrBf,EAAiBa,EAAYG,SAyB7BjB,EAAUkB,MAAMlB,UAkDHD,ECpFbQ,EAAU,oBACVC,EAAS,6BAGTM,EAAcC,OAAOC,UAMrBf,EAAiBa,EAAYG,WAsDhBb,IC1CAM,uLEmCjB,QAASS,GAAarB,GACpB,MAAOQ,GAASR,IAAUG,EAAeC,KAAKJ,IAAUsB,EA4B1D,QAASd,GAASR,GAChB,GAAIW,SAAcX,EAClB,SAASA,IAAkB,UAARW,GAA4B,YAARA,GAxFzC,GAAIW,GAAY,kBAGZC,EAA8B,gBAAV7B,IAAsBA,GAAUA,EAAOuB,SAAWA,QAAUvB,EAGhF8B,EAA4CC,IAAYA,EAAQC,UAAYD,EAG5EE,EAAaH,IAAe,GAA6BI,IAAWA,EAAOF,UAAYE,EAGvFC,EAAgBF,GAAcA,EAAWF,UAAYD,EAGrDM,EAAcD,GAAiBN,EAAWQ,QAG1CC,EAAY,WACd,IACE,MAAOF,IAAeA,EAAYG,QAAQ,QAC1C,MAAOC,QAIPC,EAAeH,GAAYA,EAASI,SAgBpCpB,EAAcC,OAAOC,UAOrBf,EAAiBa,EAAYG,SA4D7BiB,EAAWD,EA1Ef,SAAmBE,GACjB,MAAO,UAASrC,GACd,MAAOqC,GAAKrC,KAwEwBmC,GAAgBd,CAExDO,WAAiBQ,IC9GIE,yCAMdC,gBAAiB,uCAyCpB5B,EAAM0B,EAAMG,MAAKzD,iEAChB6B,EAAMD,GACR,KAAM,IAAI8B,OAAM,sEAEbnC,EAAW+B,GACd,KAAM,IAAII,OAAM,4DAEblE,GAAWmE,KAAKnE,eAChBA,KACHA,EAAW+D,EAAQK,eAAeD,OAEhC/B,YAAgBE,KAClBF,EAAOA,EAAKA,MAETpC,EAASqE,IAAIjC,IAChBpC,EAASsE,IAAIlC,QAEL/B,IAAI+B,GAAMmC,WACZT,MACDG,QACC,YACKzD,IAEL2D,kCAYH/B,EAAM0B,EAAMG,MACb5B,EAAMD,GACR,KAAM,IAAI8B,OAAM,wEAEbnC,EAAW+B,GACd,KAAM,IAAII,OAAM,8DAEblE,GAAWmE,KAAKnE,eAChBA,KACHA,EAAW+D,EAAQK,eAAeD,OAEhC/B,YAAgBE,KAClBF,EAAOA,EAAKA,MAETpC,EAASqE,IAAIjC,IAChBpC,EAASsE,IAAIlC,QAEL/B,IAAI+B,GAAMmC,WACZT,MACDG,QACC,aACK,IAELE,iCAaJ/B,EAAM0B,EAAMG,MACXjE,GAAWmE,KAAKnE,SAChBC,EAAYmC,MAGZpC,EACH,MAAOmE,SAELlE,YAAqBqC,KACvBrC,EAAYA,EAAUmC,MAEnBpC,EAASqE,IAAIpE,IAChBD,EAASsE,IAAIrE,MAEXyB,EAASzB,GAAW,IAClBG,GAAYJ,EAASK,IAAIJ,KACnBQ,QAAQ,SAACF,EAAUG,GAEzBH,EAASuD,OAASA,GAAQG,IAAQ1D,EAAS0D,KAC7C7D,EAAUO,OAAOD,EAAE,KAIG,IAArBN,EAAUS,QACZb,EAASG,OAAOF,OAEV4D,GAAS5D,MACPQ,QAAQ,SAACL,EAAWoE,GAEzBX,EAASW,IAAuB1D,EAAcb,EAAWuE,OACjD/D,QAAQ,SAACF,EAAUG,GACzBH,EAASuD,OAASA,GAAQG,IAAQ1D,EAAS0D,KAC7C7D,EAAUO,OAAOD,EAAE,KAIG,IAArBN,EAAUS,QACZb,EAASG,OAAOqE,YAKbL,mCASH/B,kBACD+B,KAAKH,mBACJhE,GAAWmE,KAAKnE,SAChByE,aAGAzE,EACH,MAAOmE,iCAPKO,kDAWZD,GADErC,YAAgBE,GACVF,EAEA,GAAIE,GAAMF,EAAM+B,KAAMO,MAE3BC,GAAe9B,MAAM+B,KAAKH,EAAMjC,MAAQkC,GAAMG,QAAQJ,aACjDhE,QAAQ,SAACL,EAAWoE,MAGjBC,EAAMrC,OAASoC,IAAuBC,EAAMrC,QAE5CqC,EAAMrC,OAASyB,EAASW,IAAuBA,EAAmBM,KAAKL,EAAMrC,SAE7EqC,EAAMrC,OAASyB,EAASW,IAAuB1D,EAAc0D,EAAoBC,EAAMrC,UAEvF3B,QAAQ,cACRqD,KAAKiB,MAAMxE,EAAS0D,IAAKU,GAC/BpE,EAASyE,MACXC,EAAKC,IAAIT,EAAMrC,KAAM7B,EAASuD,KAAMvD,EAAS0D,KAAK,OAK/CE,oCAYF/B,MAAMlC,2DAAeiF,6DACtBnF,EAAWmE,KAAKnE,SAChBC,EAAYmC,QAGZpC,IAGD0B,EAASzB,KACID,EAAUC,EAAWC,GAE7BD,YAAqBqC,QACvB8C,MAAMnF,EAAUmC,KAAM+C,EAAWjF,GAE/B2D,EAAS5D,SACV2E,KAAK5E,GAAUqF,IAAI,kBAAKC,GAAE,KAAI7E,QAAQ,eAGhC+D,IAAuBW,GAAalF,EAAU6E,KAAKN,MAEnDA,IAAuB1D,EAAc0D,EAAoBvE,OAEpDD,EAAUwE,EAAoBtE,KAInB,IAArBqF,UAAU1E,SAA8B,IAAdZ,IACxBmF,UAEY,IAAdnF,OAAqCuF,KAAdvF,GAA2BsF,UAAU1E,QAAU,MACpEJ,QAAQ,SAACL,EAAWgC,KAClB9B,OAAO,kBAAYC,GAASC,YAAWC,QAAQ,cAC9CE,OAAOP,EAAUQ,QAAQL,GAAW,KAIvB,IAArBH,EAAUS,QACZb,EAASG,OAAOiC,KAIZ+B,MAnCCA,mCA4CH/B,MAAM+C,8DACPnF,EAAWmE,KAAKnE,SAChBC,EAAYmC,MAGZpC,EACH,MAAO,MAEL0B,EAASzB,SACJD,GAASqE,IAAIpE,GAAaD,EAASK,IAAIJ,GAAWY,OAAS,CAE9D,IAAGZ,YAAqBqC,SACrBtC,GAASqE,IAAIpE,EAAUmC,MAAQpC,EAASK,IAAIJ,EAAUmC,MAAMvB,OAAS,CAExE,IAAGgD,EAAS5D,GAAW,IACvBwF,GAAQ,WACHhF,QAAQ,SAACL,EAAWoE,GACzB9C,EAAS8C,IAAuBW,GAAalF,EAAU6E,KAAKN,GAC9DiB,GAASrF,EAAUS,OACZC,EAAc0D,EAAoBvE,KACzCwF,GAASrF,EAAUS,UAEd4E,KAGHA,GAAQ,WACHhF,QAAQ,SAACL,EAAWH,MACnBG,EAAUS,SAEb4E,yCAjQD1B,GAAQ2B,YAAYvB,4CAtBTwB,UACRxB,KAAKyB,SAAWzB,KAAKyB,OAAS,GAAIC,WACjCxF,IAAIsF,0CAQMA,MACjBN,GAAMlB,KAAKyB,SAAWzB,KAAKyB,OAAS,GAAIC,UACxCD,EAAS,GAAIE,cACbxB,IAAIqB,EAASC,GACVA"}