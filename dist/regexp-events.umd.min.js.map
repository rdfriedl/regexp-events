{"version":3,"file":"regexp-events.umd.min.js","sources":["../src/Event.js","../src/utils.js","../src/Emitter.js"],"sourcesContent":["/**\n * @classdesc the basic event class\n * @class Event\n */\nexport default class Event {\n\t/**\n\t * @param  {String} type - the type of event, this can be anything, but its a good idea just to make it a string\n\t * @param  {Emitter} target - the emitter that is firing this event\n\t * @param  {Array} args - an array of arguments that is used on the listener functions\n\t * @return {Event}\n\t */\n\tconstructor(type, args, target) {\n\t\tif (typeof type !== \"string\") throw new Error(\"Event.type has to be a string\");\n\n\t\t/**\n\t\t * the type of event\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * an array of arguments that are used when calling the listener function\n\t\t * @type {Array}\n\t\t */\n\t\tthis.args = args || [];\n\n\t\t/**\n\t\t * a reference to the emitter that fired the event\n\t\t * @type {Emitter}\n\t\t */\n\t\tthis.target = target;\n\t}\n}\n","export function clearListeners(eventMap, eventType, force) {\n\tif (force) {\n\t\teventMap.delete(eventType);\n\t} else {\n\t\tlet listeners = eventMap.get(eventType);\n\t\tlisteners.filter(listener => !listener.isStatic).forEach((listener, i) => {\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t});\n\n\t\t// if there are not listeners left, remove the array\n\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t}\n}\n\nexport function isRegExpEqual(r1, r2) {\n\treturn (\n\t\tr1 instanceof RegExp &&\n\t\tr2 instanceof RegExp &&\n\t\tr2.source === r1.source &&\n\t\tr2.global === r1.global &&\n\t\tr2.ignoreCase === r1.ignoreCase &&\n\t\tr2.multiline === r1.multiline &&\n\t\tr2.sticky === r1.sticky &&\n\t\tr2.unicode === r1.unicode\n\t);\n}\n","import Event from \"./Event\";\nimport { clearListeners, isRegExpEqual } from \"./utils\";\n\nfunction isBoolean(v) {\n\treturn v === true || v === false;\n}\n\nfunction findInArgArray(args, fn, start, df) {\n\tfor (let i = 0; i < args.length - start; i++) if (fn(args[start + i])) return args[start + i];\n\n\treturn df;\n}\n\n/**\n * a simple event emitter\n */\nexport default class Emitter {\n\tconstructor() {\n\t\t/**\n\t\t * whether to suppress all events on this emitter\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.suppressEvents = false;\n\t}\n\n\t/**\n\t * returns the Map that is used to store events for emitters\n\t * @param {Emitter} emitter\n\t * @return {WeakMap}\n\t */\n\tstatic getEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\treturn map.get(emitter);\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic createEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tlet events = new Map();\n\t\tmap.set(emitter, events);\n\t\treturn events;\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic removeEventMap(emitter) {\n\t\tlet map = this.events;\n\t\tif (map && emitter && map.has(emitter)) {\n\t\t\tmap.delete(emitter);\n\t\t}\n\t}\n\n\t/**\n\t * returns the Map used to store events\n\t * @return {Map}\n\t */\n\tget eventMap() {\n\t\treturn Emitter.getEventMap(this);\n\t}\n\n\t/**\n\t * listens for an event of this emitter\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - the function to be called when the event fires\n\t * @param  {Object|Boolean|Number} [context] - the context to run the function under\n\t * @param  {Boolean|Number|Object} [isStatic=true] - whether this listener can be removed without force\n\t * @param  {Number|Boolean|Object} [times=Infinity] the times this listener can be called before it removes it self\n\t * @return {this}\n\t */\n\ton(eventType, listener, context, isStatic, times) {\n\t\tif (typeof eventType !== \"string\" && !(eventType instanceof RegExp) && !(eventType instanceof Event))\n\t\t\tthrow new Error(\"Emitter.on requires a String, Event or RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.on requires a function as the second argument\");\n\n\t\tisStatic = findInArgArray(arguments, isBoolean, 2, false);\n\t\ttimes = findInArgArray(arguments, n => Number.isFinite(n) || n === Infinity, 2, Infinity);\n\t\tcontext = findInArgArray(\n\t\t\targuments,\n\t\t\to => {\n\t\t\t\treturn typeof o === \"object\";\n\t\t\t},\n\t\t\t2,\n\t\t\tundefined,\n\t\t);\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) eventMap = Emitter.createEventMap(this);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\t// add the listener to the array\n\t\teventMap.get(eventType).push({\n\t\t\tfunc: listener,\n\t\t\tctx: context,\n\t\t\ttimes: times,\n\t\t\tisStatic: isStatic,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * binds a listener that removes its self once the event is fired\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener\n\t * @param  {Object|Boolean} [context] - the context to run the functions under\n\t * @param  {Boolean|Object} [isStatic = false] - whether this listener can be removed without using force\n\t * @return {this}\n\t */\n\tonce(eventType, listener, context, isStatic) {\n\t\treturn this.on(eventType, listener, 1, context, isStatic);\n\t}\n\n\t/**\n\t * removes a listener\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - this has to be the exact function that was bound\n\t * @param  {*|Boolean} [context] - this has to be the exact context that was bound with the listener\n\t * @param  {Boolean} [force=false] - whether to force remove the listeners\n\t * @return {this}\n\t */\n\toff(eventType, listener, context, force) {\n\t\tif (eventType == null) throw new Error(\"Emitter.off requires a String or a RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.off requires a function as the second argument\");\n\n\t\tforce = findInArgArray(arguments, isBoolean, 2, false);\n\t\tcontext = findInArgArray(arguments, o => typeof o === \"object\", 2, undefined);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) return this; // if there is not event map, just exit\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tlet listeners = eventMap.get(eventType);\n\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\tif (listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic ? force : true))\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t});\n\n\t\t\t// remove the listener array if there are no listeners left\n\t\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\t// if the regexp flags and source match then remove the listeners\n\t\t\t\tif (listenersEventType instanceof RegExp && isRegExpEqual(eventType, listenersEventType)) {\n\t\t\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tlistenerData.func === listener &&\n\t\t\t\t\t\t\tlistenerData.ctx === context &&\n\t\t\t\t\t\t\t(listenerData.isStatic ? force : true)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\t// remove the listener array if there are no listeners left\n\t\t\t\t\tif (listeners.length === 0) eventMap.delete(listenersEventType);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * fires ad event on this emitter\n\t * @param {String|Event} eventType\n\t * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in\n\t * @return {this}\n\t */\n\temit(eventType, ...args) {\n\t\tif (this.suppressEvents) return;\n\t\tlet eventMap = this.eventMap;\n\t\tlet event;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\t// if its an event use the events type\n\t\tif (eventType instanceof Event) {\n\t\t\tevent = eventType;\n\n\t\t\t// if the event dose not have a target set it to this emitter\n\t\t\tif (event.target === undefined) event.target = this;\n\t\t} else if (typeof eventType === \"string\") event = new Event(eventType, args, this);\n\t\telse throw new Error(\"Emitter.emit requires a String or Event as the first argument\");\n\n\t\tlet listenerArgs = Array.from(event.args).concat([event]);\n\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\tif (\n\t\t\t\t// if they are both strings and they match\n\t\t\t\t(typeof event.type === \"string\" && listenersEventType === event.type) ||\n\t\t\t\t// if the listenersEventType is a RegExp and the event type is a string, see if they match\n\t\t\t\t(typeof event.type === \"string\" &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tlistenersEventType.test(event.type)) ||\n\t\t\t\t// if they are both RegExp see if they match\n\t\t\t\t(event.type instanceof RegExp &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tisRegExpEqual(listenersEventType, event.type))\n\t\t\t) {\n\t\t\t\tlisteners.forEach(listener => {\n\t\t\t\t\tlistener.func.apply(listener.ctx, listenerArgs);\n\t\t\t\t\tif (--listener.times <= 0) this.off(event.type, listener.func, listener.ctx, true);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * removes all events of \"eventType\"\n\t * NOTE: passing no arguments will clean all listeners\n\t * NOTE: passing a single boolean will clear all listens and act as the force flag\n\t * @param {RegExp|String|Event|Boolean} [eventType] - the type of event\n\t * @param {Boolean} [force = false] - whether to force remove the listeners\n\t * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types\n\t * @return {this}\n\t */\n\tclear(eventType, force = false, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is no event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tclearListeners(eventMap, eventType, force);\n\t\t} else if (eventType instanceof Event) {\n\t\t\tclearListeners(eventMap, eventType.type, force);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tArray.from(eventMap)\n\t\t\t\t.map(a => a[0])\n\t\t\t\t.forEach(listenersEventType => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclearListeners(eventMap, listenersEventType, force);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t} else if (arguments.length === 1 && eventType === true) {\n\t\t\t// remove all listeners\n\t\t\teventMap.clear();\n\t\t} else if ((eventType === false || eventType === undefined) && arguments.length <= 1) {\n\t\t\t// remove all listeners that are not static\n\t\t\teventMap.forEach((listeners, type) => {\n\t\t\t\tlisteners.filter(listener => !listener.isStatic).forEach(listener => {\n\t\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t\t\t});\n\n\t\t\t\t// if there are no listeners left, remove the array\n\t\t\t\tif (listeners.length === 0) eventMap.delete(type);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * returns the number of listeners bound to the event\n\t * @param  {RegExp|String|Event} [eventType]\n\t * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types\n\t * @return {Boolean}\n\t */\n\tcount(eventType, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return 0;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\treturn eventMap.has(eventType) ? eventMap.get(eventType).length : 0;\n\t\t} else if (eventType instanceof Event) {\n\t\t\treturn eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\tif (\n\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t) {\n\t\t\t\t\ttotal += listeners.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn total;\n\t\t} else {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach(listeners => {\n\t\t\t\ttotal += listeners.length;\n\t\t\t});\n\t\t\treturn total;\n\t\t}\n\t}\n\n\t/**\n\t * cleans up the emitter for GC\n\t */\n\tdispose() {\n\t\tEmitter.removeEventMap(this);\n\t\treturn this;\n\t}\n}\n"],"names":["Event","type","args","target","Error","clearListeners","eventMap","eventType","force","delete","listeners","get","filter","listener","isStatic","forEach","i","splice","indexOf","length","isRegExpEqual","r1","r2","RegExp","source","global","ignoreCase","multiline","sticky","unicode","isBoolean","v","findInArgArray","fn","start","df","Emitter","suppressEvents","context","times","arguments","Number","isFinite","n","Infinity","o","undefined","this","createEventMap","has","set","push","on","listenerData","func","ctx","listenersEventType","event","listenerArgs","Array","from","concat","test","apply","_this","off","useRegExp","map","a","clear","total","removeEventMap","getEventMap","emitter","events","WeakMap","Map"],"mappings":"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"}