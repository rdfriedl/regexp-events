{"version":3,"file":"regexp-events.es.js","sources":["../src/Event.js","../src/utils.js","../src/Emitter.js"],"sourcesContent":["/**\n * @classdesc the basic event class\n * @class Event\n */\nexport default class Event {\n\t/**\n\t * @param  {String} type - the type of event, this can be anything, but its a good idea just to make it a string\n\t * @param  {Emitter} target - the emitter that is firing this event\n\t * @param  {Array} args - an array of arguments that is used on the listener functions\n\t * @return {Event}\n\t */\n\tconstructor(type, args, target) {\n\t\tif (typeof type !== \"string\") throw new Error(\"Event.type has to be a string\");\n\n\t\t/**\n\t\t * the type of event\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * an array of arguments that are used when calling the listener function\n\t\t * @type {Array}\n\t\t */\n\t\tthis.args = args || [];\n\n\t\t/**\n\t\t * a reference to the emitter that fired the event\n\t\t * @type {Emitter}\n\t\t */\n\t\tthis.target = target;\n\t}\n}\n","export function clearListeners(eventMap, eventType, force) {\n\tif (force) {\n\t\teventMap.delete(eventType);\n\t} else {\n\t\tlet listeners = eventMap.get(eventType);\n\t\tlisteners.filter(listener => !listener.isStatic).forEach((listener, i) => {\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t});\n\n\t\t// if there are not listeners left, remove the array\n\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t}\n}\n\nexport function isRegExpEqual(r1, r2) {\n\treturn (\n\t\tr1 instanceof RegExp &&\n\t\tr2 instanceof RegExp &&\n\t\tr2.source === r1.source &&\n\t\tr2.global === r1.global &&\n\t\tr2.ignoreCase === r1.ignoreCase &&\n\t\tr2.multiline === r1.multiline &&\n\t\tr2.sticky === r1.sticky &&\n\t\tr2.unicode === r1.unicode\n\t);\n}\n","import Event from \"./Event\";\nimport { clearListeners, isRegExpEqual } from \"./utils\";\n\nfunction isBoolean(v) {\n\treturn v === true || v === false;\n}\n\nfunction findInArgArray(args, fn, start, df) {\n\tfor (let i = 0; i < args.length - start; i++) if (fn(args[start + i])) return args[start + i];\n\n\treturn df;\n}\n\n/**\n * a simple event emitter\n */\nexport default class Emitter {\n\tconstructor() {\n\t\t/**\n\t\t * whether to suppress all events on this emitter\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.suppressEvents = false;\n\t}\n\n\t/**\n\t * returns the Map that is used to store events for emitters\n\t * @param {Emitter} emitter\n\t * @return {WeakMap}\n\t */\n\tstatic getEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\treturn map.get(emitter);\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic createEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tlet events = new Map();\n\t\tmap.set(emitter, events);\n\t\treturn events;\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic removeEventMap(emitter) {\n\t\tlet map = this.events;\n\t\tif (map && emitter && map.has(emitter)) {\n\t\t\tmap.delete(emitter);\n\t\t}\n\t}\n\n\t/**\n\t * returns the Map used to store events\n\t * @return {Map}\n\t */\n\tget eventMap() {\n\t\treturn Emitter.getEventMap(this);\n\t}\n\n\t/**\n\t * listens for an event of this emitter\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - the function to be called when the event fires\n\t * @param  {Object|Boolean|Number} [context] - the context to run the function under\n\t * @param  {Boolean|Number|Object} [isStatic=true] - whether this listener can be removed without force\n\t * @param  {Number|Boolean|Object} [times=Infinity] the times this listener can be called before it removes it self\n\t * @return {this}\n\t */\n\ton(eventType, listener, context, isStatic, times) {\n\t\tif (typeof eventType !== \"string\" && !(eventType instanceof RegExp) && !(eventType instanceof Event))\n\t\t\tthrow new Error(\"Emitter.on requires a String, Event or RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.on requires a function as the second argument\");\n\n\t\tisStatic = findInArgArray(arguments, isBoolean, 2, false);\n\t\ttimes = findInArgArray(arguments, n => Number.isFinite(n) || n === Infinity, 2, Infinity);\n\t\tcontext = findInArgArray(\n\t\t\targuments,\n\t\t\to => {\n\t\t\t\treturn typeof o === \"object\";\n\t\t\t},\n\t\t\t2,\n\t\t\tundefined,\n\t\t);\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) eventMap = Emitter.createEventMap(this);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\t// add the listener to the array\n\t\teventMap.get(eventType).push({\n\t\t\tfunc: listener,\n\t\t\tctx: context,\n\t\t\ttimes: times,\n\t\t\tisStatic: isStatic,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * binds a listener that removes its self once the event is fired\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener\n\t * @param  {Object|Boolean} [context] - the context to run the functions under\n\t * @param  {Boolean|Object} [isStatic = false] - whether this listener can be removed without using force\n\t * @return {this}\n\t */\n\tonce(eventType, listener, context, isStatic) {\n\t\treturn this.on(eventType, listener, 1, context, isStatic);\n\t}\n\n\t/**\n\t * removes a listener\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - this has to be the exact function that was bound\n\t * @param  {*|Boolean} [context] - this has to be the exact context that was bound with the listener\n\t * @param  {Boolean} [force=false] - whether to force remove the listeners\n\t * @return {this}\n\t */\n\toff(eventType, listener, context, force) {\n\t\tif (eventType == null) throw new Error(\"Emitter.off requires a String or a RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.off requires a function as the second argument\");\n\n\t\tforce = findInArgArray(arguments, isBoolean, 2, false);\n\t\tcontext = findInArgArray(arguments, o => typeof o === \"object\", 2, undefined);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) return this; // if there is not event map, just exit\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tlet listeners = eventMap.get(eventType);\n\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\tif (listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic ? force : true))\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t});\n\n\t\t\t// remove the listener array if there are no listeners left\n\t\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\t// if the regexp flags and source match then remove the listeners\n\t\t\t\tif (listenersEventType instanceof RegExp && isRegExpEqual(eventType, listenersEventType)) {\n\t\t\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tlistenerData.func === listener &&\n\t\t\t\t\t\t\tlistenerData.ctx === context &&\n\t\t\t\t\t\t\t(listenerData.isStatic ? force : true)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\t// remove the listener array if there are no listeners left\n\t\t\t\t\tif (listeners.length === 0) eventMap.delete(listenersEventType);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * fires ad event on this emitter\n\t * @param {String|Event} eventType\n\t * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in\n\t * @return {this}\n\t */\n\temit(eventType, ...args) {\n\t\tif (this.suppressEvents) return;\n\t\tlet eventMap = this.eventMap;\n\t\tlet event;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\t// if its an event use the events type\n\t\tif (eventType instanceof Event) {\n\t\t\tevent = eventType;\n\n\t\t\t// if the event dose not have a target set it to this emitter\n\t\t\tif (event.target === undefined) event.target = this;\n\t\t} else if (typeof eventType === \"string\") event = new Event(eventType, args, this);\n\t\telse throw new Error(\"Emitter.emit requires a String or Event as the first argument\");\n\n\t\tlet listenerArgs = Array.from(event.args).concat([event]);\n\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\tif (\n\t\t\t\t// if they are both strings and they match\n\t\t\t\t(typeof event.type === \"string\" && listenersEventType === event.type) ||\n\t\t\t\t// if the listenersEventType is a RegExp and the event type is a string, see if they match\n\t\t\t\t(typeof event.type === \"string\" &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tlistenersEventType.test(event.type)) ||\n\t\t\t\t// if they are both RegExp see if they match\n\t\t\t\t(event.type instanceof RegExp &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tisRegExpEqual(listenersEventType, event.type))\n\t\t\t) {\n\t\t\t\tlisteners.forEach(listener => {\n\t\t\t\t\tlistener.func.apply(listener.ctx, listenerArgs);\n\t\t\t\t\tif (--listener.times <= 0) this.off(event.type, listener.func, listener.ctx, true);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * removes all events of \"eventType\"\n\t * NOTE: passing no arguments will clean all listeners\n\t * NOTE: passing a single boolean will clear all listens and act as the force flag\n\t * @param {RegExp|String|Event|Boolean} [eventType] - the type of event\n\t * @param {Boolean} [force = false] - whether to force remove the listeners\n\t * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types\n\t * @return {this}\n\t */\n\tclear(eventType, force = false, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is no event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tclearListeners(eventMap, eventType, force);\n\t\t} else if (eventType instanceof Event) {\n\t\t\tclearListeners(eventMap, eventType.type, force);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tArray.from(eventMap)\n\t\t\t\t.map(a => a[0])\n\t\t\t\t.forEach(listenersEventType => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclearListeners(eventMap, listenersEventType, force);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t} else if (arguments.length === 1 && eventType === true) {\n\t\t\t// remove all listeners\n\t\t\teventMap.clear();\n\t\t} else if ((eventType === false || eventType === undefined) && arguments.length <= 1) {\n\t\t\t// remove all listeners that are not static\n\t\t\teventMap.forEach((listeners, type) => {\n\t\t\t\tlisteners.filter(listener => !listener.isStatic).forEach(listener => {\n\t\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t\t\t});\n\n\t\t\t\t// if there are no listeners left, remove the array\n\t\t\t\tif (listeners.length === 0) eventMap.delete(type);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * returns the number of listeners bound to the event\n\t * @param  {RegExp|String|Event} [eventType]\n\t * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types\n\t * @return {Boolean}\n\t */\n\tcount(eventType, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return 0;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\treturn eventMap.has(eventType) ? eventMap.get(eventType).length : 0;\n\t\t} else if (eventType instanceof Event) {\n\t\t\treturn eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\tif (\n\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t) {\n\t\t\t\t\ttotal += listeners.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn total;\n\t\t} else {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach(listeners => {\n\t\t\t\ttotal += listeners.length;\n\t\t\t});\n\t\t\treturn total;\n\t\t}\n\t}\n\n\t/**\n\t * cleans up the emitter for GC\n\t */\n\tdispose() {\n\t\tEmitter.removeEventMap(this);\n\t\treturn this;\n\t}\n}\n"],"names":[],"mappings":"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"}