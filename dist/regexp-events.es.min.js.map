{"version":3,"file":"regexp-events.es.min.js","sources":["../src/utils.js","../src/Emitter.js","../src/Event.js"],"sourcesContent":["export function clearListeners(eventMap, eventType, force) {\n\tif (force) {\n\t\teventMap.delete(eventType);\n\t} else {\n\t\tlet listeners = eventMap.get(eventType);\n\t\tlisteners.filter(listener => !listener.isStatic).forEach((listener, i) => {\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t});\n\n\t\t// if there are not listeners left, remove the array\n\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t}\n}\n\nexport function isRegExpEqual(r1, r2) {\n\treturn (\n\t\tr1 instanceof RegExp &&\n\t\tr2 instanceof RegExp &&\n\t\tr2.source === r1.source &&\n\t\tr2.global === r1.global &&\n\t\tr2.ignoreCase === r1.ignoreCase &&\n\t\tr2.multiline === r1.multiline &&\n\t\tr2.sticky === r1.sticky &&\n\t\tr2.unicode === r1.unicode\n\t);\n}\n","import Event from \"./Event\";\nimport { clearListeners, isRegExpEqual } from \"./utils\";\n\nfunction isBoolean(v) {\n\treturn v === true || v === false;\n}\n\nfunction findInArgArray(args, fn, start, df) {\n\tfor (let i = 0; i < args.length - start; i++) if (fn(args[start + i])) return args[start + i];\n\n\treturn df;\n}\n\n/**\n * a simple event emitter\n */\nexport default class Emitter {\n\tconstructor() {\n\t\t/**\n\t\t * whether to suppress all events on this emitter\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.suppressEvents = false;\n\t}\n\n\t/**\n\t * returns the Map that is used to store events for emitters\n\t * @param {Emitter} emitter\n\t * @return {WeakMap}\n\t */\n\tstatic getEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\treturn map.get(emitter);\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic createEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tlet events = new Map();\n\t\tmap.set(emitter, events);\n\t\treturn events;\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic removeEventMap(emitter) {\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tif (map.has(emitter)) map.delete(emitter);\n\t}\n\n\t/**\n\t * returns the Map used to store events\n\t * @return {Map}\n\t */\n\tget eventMap() {\n\t\treturn Emitter.getEventMap(this);\n\t}\n\n\t/**\n\t * listens for an event of this emitter\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - the function to be called when the event fires\n\t * @param  {Object|Boolean|Number} [context] - the context to run the function under\n\t * @param  {Boolean|Number|Object} [isStatic=true] - whether this listener can be removed without force\n\t * @param  {Number|Boolean|Object} [times=Infinity] the times this listener can be called before it removes it self\n\t * @return {this}\n\t */\n\ton(eventType, listener, context, isStatic, times) {\n\t\tif (typeof eventType !== \"string\" && !(eventType instanceof RegExp) && !(eventType instanceof Event))\n\t\t\tthrow new Error(\"Emitter.on requires a String, Event or RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.on requires a function as the second argument\");\n\n\t\tisStatic = findInArgArray(arguments, isBoolean, 2, false);\n\t\ttimes = findInArgArray(arguments, n => Number.isFinite(n) || n === Infinity, 2, Infinity);\n\t\tcontext = findInArgArray(\n\t\t\targuments,\n\t\t\to => {\n\t\t\t\treturn typeof o === \"object\";\n\t\t\t},\n\t\t\t2,\n\t\t\tundefined,\n\t\t);\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) eventMap = Emitter.createEventMap(this);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\t// add the listener to the array\n\t\teventMap.get(eventType).push({\n\t\t\tfunc: listener,\n\t\t\tctx: context,\n\t\t\ttimes: times,\n\t\t\tisStatic: isStatic,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * binds a listener that removes its self once the event is fired\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener\n\t * @param  {Object|Boolean} [context] - the context to run the functions under\n\t * @param  {Boolean|Object} [isStatic = false] - whether this listener can be removed without using force\n\t * @return {this}\n\t */\n\tonce(eventType, listener, context, isStatic) {\n\t\treturn this.on(eventType, listener, 1, context, isStatic);\n\t}\n\n\t/**\n\t * removes a listener\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - this has to be the exact function that was bound\n\t * @param  {*|Boolean} [context] - this has to be the exact context that was bound with the listener\n\t * @param  {Boolean} [force=false] - whether to force remove the listeners\n\t * @return {this}\n\t */\n\toff(eventType, listener, context, force) {\n\t\tif (eventType == null) throw new Error(\"Emitter.off requires a String or a RegExp as the first argument\");\n\n\t\tif (typeof listener !== \"function\") throw new Error(\"Emitter.off requires a function as the second argument\");\n\n\t\tforce = findInArgArray(arguments, isBoolean, 2, false);\n\t\tcontext = findInArgArray(arguments, o => typeof o === \"object\", 2, undefined);\n\n\t\tif (eventType instanceof Event) eventType = eventType.type;\n\n\t\tlet eventMap = this.eventMap;\n\t\tif (!eventMap) return this; // if there is not event map, just exit\n\n\t\tif (!eventMap.has(eventType)) eventMap.set(eventType, []);\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tlet listeners = eventMap.get(eventType);\n\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\tif (listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic ? force : true))\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t});\n\n\t\t\t// remove the listener array if there are no listeners left\n\t\t\tif (listeners.length === 0) eventMap.delete(eventType);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\t// if the regexp flags and source match then remove the listeners\n\t\t\t\tif (listenersEventType instanceof RegExp && isRegExpEqual(eventType, listenersEventType)) {\n\t\t\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tlistenerData.func === listener &&\n\t\t\t\t\t\t\tlistenerData.ctx === context &&\n\t\t\t\t\t\t\t(listenerData.isStatic ? force : true)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\t// remove the listener array if there are no listeners left\n\t\t\t\t\tif (listeners.length === 0) eventMap.delete(listenersEventType);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * fires ad event on this emitter\n\t * @param {String|Event} eventType\n\t * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in\n\t * @return {this}\n\t */\n\temit(eventType, ...args) {\n\t\tif (this.suppressEvents) return;\n\t\tlet eventMap = this.eventMap;\n\t\tlet event;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\t// if its an event use the events type\n\t\tif (eventType instanceof Event) {\n\t\t\tevent = eventType;\n\n\t\t\t// if the event dose not have a target set it to this emitter\n\t\t\tif (event.target === undefined) event.target = this;\n\t\t} else if (typeof eventType === \"string\") event = new Event(eventType, args, this);\n\t\telse throw new Error(\"Emitter.emit requires a String or Event as the first argument\");\n\n\t\tlet listenerArgs = Array.from(event.args).concat([event]);\n\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\tif (\n\t\t\t\t// if they are both strings and they match\n\t\t\t\t(typeof event.type === \"string\" && listenersEventType === event.type) ||\n\t\t\t\t// if the listenersEventType is a RegExp and the event type is a string, see if they match\n\t\t\t\t(typeof event.type === \"string\" &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tlistenersEventType.test(event.type)) ||\n\t\t\t\t// if they are both RegExp see if they match\n\t\t\t\t(event.type instanceof RegExp &&\n\t\t\t\t\tlistenersEventType instanceof RegExp &&\n\t\t\t\t\tisRegExpEqual(listenersEventType, event.type))\n\t\t\t) {\n\t\t\t\tlisteners.forEach(listener => {\n\t\t\t\t\tlistener.func.apply(listener.ctx, listenerArgs);\n\t\t\t\t\tif (--listener.times <= 0) this.off(event.type, listener.func, listener.ctx, true);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * removes all events of \"eventType\"\n\t * NOTE: passing no arguments will clean all listeners\n\t * NOTE: passing a single boolean will clear all listens and act as the force flag\n\t * @param {RegExp|String|Event|Boolean} [eventType] - the type of event\n\t * @param {Boolean} [force = false] - whether to force remove the listeners\n\t * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types\n\t * @return {this}\n\t */\n\tclear(eventType, force = false, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is no event map, just exit\n\t\tif (!eventMap) return this;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\tclearListeners(eventMap, eventType, force);\n\t\t} else if (eventType instanceof Event) {\n\t\t\tclearListeners(eventMap, eventType.type, force);\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tArray.from(eventMap)\n\t\t\t\t.map(a => a[0])\n\t\t\t\t.forEach(listenersEventType => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclearListeners(eventMap, listenersEventType, force);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t} else if (arguments.length === 1 && eventType === true) {\n\t\t\t// remove all listeners\n\t\t\teventMap.clear();\n\t\t} else if ((eventType === false || eventType === undefined) && arguments.length <= 1) {\n\t\t\t// remove all listeners that are not static\n\t\t\teventMap.forEach((listeners, type) => {\n\t\t\t\tlisteners.filter(listener => !listener.isStatic).forEach(listener => {\n\t\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t\t\t});\n\n\t\t\t\t// if there are no listeners left, remove the array\n\t\t\t\tif (listeners.length === 0) eventMap.delete(type);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * returns the number of listeners bound to the event\n\t * @param  {RegExp|String|Event} [eventType]\n\t * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types\n\t * @return {Boolean}\n\t */\n\tcount(eventType, useRegExp = true) {\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is not event map, just exit\n\t\tif (!eventMap) return 0;\n\n\t\tif (typeof eventType === \"string\") {\n\t\t\treturn eventMap.has(eventType) ? eventMap.get(eventType).length : 0;\n\t\t} else if (eventType instanceof Event) {\n\t\t\treturn eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;\n\t\t} else if (eventType instanceof RegExp) {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\tif (\n\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t(typeof listenersEventType === \"string\" && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t(listenersEventType instanceof RegExp && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t) {\n\t\t\t\t\ttotal += listeners.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn total;\n\t\t} else {\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach(listeners => {\n\t\t\t\ttotal += listeners.length;\n\t\t\t});\n\t\t\treturn total;\n\t\t}\n\t}\n\n\t/**\n\t * cleans up the emitter for GC\n\t */\n\tdispose() {\n\t\tEmitter.removeEventMap(this);\n\t\treturn this;\n\t}\n}\n","/**\n * @classdesc the basic event class\n * @class Event\n */\nexport default class Event {\n\t/**\n\t * @param  {String} type - the type of event, this can be anything, but its a good idea just to make it a string\n\t * @param  {Emitter} target - the emitter that is firing this event\n\t * @param  {Array} args - an array of arguments that is used on the listener functions\n\t * @return {Event}\n\t */\n\tconstructor(type, args, target) {\n\t\tif (typeof type !== \"string\") throw new Error(\"Event.type has to be a string\");\n\n\t\t/**\n\t\t * the type of event\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * an array of arguments that are used when calling the listener function\n\t\t * @type {Array}\n\t\t */\n\t\tthis.args = args || [];\n\n\t\t/**\n\t\t * a reference to the emitter that fired the event\n\t\t * @type {Emitter}\n\t\t */\n\t\tthis.target = target;\n\t}\n}\n"],"names":["clearListeners","eventMap","eventType","force","delete","listeners","get","filter","listener","isStatic","forEach","i","splice","indexOf","length","isRegExpEqual","r1","r2","RegExp","source","global","ignoreCase","multiline","sticky","unicode","isBoolean","v","findInArgArray","args","fn","start","df","Event","[object Object]","type","target","Error","this","Emitter","suppressEvents","emitter","events","WeakMap","map","Map","set","has","getEventMap","context","times","arguments","n","Number","isFinite","Infinity","o","undefined","createEventMap","push","func","ctx","on","listenerData","listenersEventType","event","listenerArgs","Array","from","concat","test","apply","off","useRegExp","a","clear","total","removeEventMap"],"mappings":"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"}