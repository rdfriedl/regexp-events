{"version":3,"file":"regexp-events.es.min.js","sources":["../node_modules/lodash.isstring/index.js","../src/utils.js","../node_modules/lodash.isfunction/index.js","../src/Emitter.js","../src/Event.js","../node_modules/lodash.isregexp/index.js"],"sourcesContent":["/**\n * lodash 4.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @type Function\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n}\n\nmodule.exports = isString;\n","export function clearListeners(eventMap, eventType, force){\n\tif(force) {\n\t\teventMap.delete(eventType);\n\t}\n\telse {\n\t\tlet listeners = eventMap.get(eventType);\n\t\tlisteners.filter(listener => !listener.isStatic).forEach((listener, i) => {\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t});\n\n\t\t// if there are not listeners left, remove the array\n\t\tif(listeners.length === 0)\n\t\t\teventMap.delete(eventType);\n\t}\n}\n\nexport function isRegExpEqual(r1, r2){\n\treturn (\n\t\tr1 instanceof RegExp &&\n\t\tr2 instanceof RegExp &&\n\t\tr2.source === r1.source &&\n\t\tr2.global === r1.global &&\n\t\tr2.ignoreCase === r1.ignoreCase &&\n\t\tr2.multiline === r1.multiline &&\n\t\tr2.sticky === r1.sticky &&\n\t\tr2.unicode === r1.unicode\n\t);\n}","/**\n * lodash 3.0.8 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8 which returns 'object' for typed array constructors, and\n  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isFunction;\n","import Event from './Event';\nimport {clearListeners, isRegExpEqual} from './utils';\nimport isString from 'lodash.isstring';\nimport isFunction from 'lodash.isfunction';\nimport isRegExp from 'lodash.isregexp';\n\nfunction isBoolean(v) {\n\treturn v === true || v === false;\n}\n\nfunction findInArgArray(args, fn, start, df) {\n\tfor(let i = 0; i < args.length-start; i++)\n\t\tif(fn(args[start+i]))\n\t\t\treturn args[start+i];\n\n\treturn df;\n}\n\n/**\n * a simple event emitter\n */\nexport default class Emitter{\n\tconstructor(){\n\t\t/**\n\t\t * whether to suppress all events on this emitter\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.suppressEvents = false;\n\t}\n\n\t/**\n\t * returns the Map that is used to store events for emitters\n\t * @param {Emitter} emitter\n\t * @return {WeakMap}\n\t */\n\tstatic getEventMap(emitter){\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\treturn map.get(emitter);\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic createEventMap(emitter){\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tlet events = new Map();\n\t\tmap.set(emitter, events);\n\t\treturn events;\n\t}\n\n\t/**\n\t * creates a new Map for the emitter\n\t * @param {Emitter} emitter\n\t * @return {Map}\n\t */\n\tstatic removeEventMap(emitter){\n\t\tlet map = this.events || (this.events = new WeakMap());\n\t\tif(map.has(emitter))\n\t\t\tmap.delete(emitter);\n\t}\n\n\t/**\n\t * returns the Map used to store events\n\t * @return {Map}\n\t */\n\tget eventMap() {\n\t\treturn Emitter.getEventMap(this);\n\t}\n\n\t/**\n\t * listens for an event of this emitter\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - the function to be called when the event fires\n\t * @param  {Object|Boolean|Number} [context] - the context to run the function under\n\t * @param  {Boolean|Number|Object} [isStatic=true] - whether this listener can be removed without force\n\t * @param  {Number|Boolean|Object} [times=Infinity] the times this listener can be called before it removes it self\n\t * @return {this}\n\t */\n\ton(eventType, listener, context, isStatic, times){\n\t\tif(!isString(eventType) && !isRegExp(eventType) && !(eventType instanceof Event))\n\t\t\tthrow new Error('Emitter.on requires a String, Event or RegExp as the first argument');\n\n\t\tif(!isFunction(listener))\n\t\t\tthrow new Error('Emitter.on requires a function as the second argument');\n\n\t\tisStatic = findInArgArray(arguments, isBoolean, 2, false);\n\t\ttimes = findInArgArray(arguments, n => Number.isFinite(n) || n === Infinity, 2, Infinity);\n\t\tcontext = findInArgArray(arguments, o => {\n\t\t\treturn typeof o === 'object';\n\t\t}, 2, undefined);\n\n\t\tlet eventMap = this.eventMap;\n\t\tif(!eventMap)\n\t\t\teventMap = Emitter.createEventMap(this);\n\n\t\tif(eventType instanceof Event)\n\t\t\teventType = eventType.type;\n\n\t\tif(!eventMap.has(eventType))\n\t\t\teventMap.set(eventType, []);\n\n\t\t// add the listener to the array\n\t\teventMap.get(eventType).push({\n\t\t\tfunc: listener,\n\t\t\tctx: context,\n\t\t\ttimes: times,\n\t\t\tisStatic: isStatic\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * binds a listener that removes its self once the event is fired\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener\n\t * @param  {Object|Boolean} [context] - the context to run the functions under\n\t * @param  {Boolean|Object} [isStatic = false] - whether this listener can be removed without using force\n\t * @return {this}\n\t */\n\tonce(eventType, listener, context, isStatic){\n\t\treturn this.on(eventType, listener, 1, context, isStatic);\n\t}\n\n\t/**\n\t * removes a listener\n\t * @param  {RegExp|String|Event} eventType\n\t * @param  {Function} listener - this has to be the exact function that was bound\n\t * @param  {*|Boolean} [context] - this has to be the exact context that was bound with the listener\n\t * @param  {Boolean} [force=false] - whether to force remove the listeners\n\t * @return {this}\n\t */\n\toff(eventType, listener, context, force){\n\t\tif(eventType == null)\n\t\t\tthrow new Error('Emitter.off requires a String or a RegExp as the first argument');\n\n\t\tif(!isFunction(listener))\n\t\t\tthrow new Error('Emitter.off requires a function as the second argument');\n\n\t\tforce = findInArgArray(arguments, isBoolean, 2, false);\n\t\tcontext = findInArgArray(arguments, o => typeof o === 'object', 2, undefined);\n\n\t\tif(eventType instanceof Event)\n\t\t\teventType = eventType.type;\n\n\t\tlet eventMap = this.eventMap;\n\t\tif(!eventMap)\n\t\t\treturn this; // if there is not event map, just exit\n\n\t\tif(!eventMap.has(eventType))\n\t\t\teventMap.set(eventType, []);\n\n\t\tif(isString(eventType)){\n\t\t\tlet listeners = eventMap.get(eventType);\n\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\tif(listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic? force : true))\n\t\t\t\t\tlisteners.splice(i,1);\n\t\t\t});\n\n\t\t\t// remove the listener array if there are no listeners left\n\t\t\tif(listeners.length === 0)\n\t\t\t\teventMap.delete(eventType);\n\t\t}\n\t\telse if(isRegExp(eventType)){\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\t// if the regexp flags and source match then remove the listeners\n\t\t\t\tif(isRegExp(listenersEventType) && isRegExpEqual(eventType, listenersEventType)){\n\t\t\t\t\tlisteners.forEach((listenerData, i) => {\n\t\t\t\t\t\tif(listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic? force : true))\n\t\t\t\t\t\t\tlisteners.splice(i,1);\n\t\t\t\t\t});\n\n\t\t\t\t\t// remove the listener array if there are no listeners left\n\t\t\t\t\tif(listeners.length === 0)\n\t\t\t\t\t\teventMap.delete(listenersEventType);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * fires ad event on this emitter\n\t * @param {String|Event} eventType\n\t * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in\n\t * @return {this}\n\t */\n\temit(eventType, ...args){\n\t\tif(this.suppressEvents) return;\n\t\tlet eventMap = this.eventMap;\n\t\tlet event;\n\n\t\t// if there is not event map, just exit\n\t\tif(!eventMap)\n\t\t\treturn this;\n\n\t\t// if its an event use the events type\n\t\tif(eventType instanceof Event){\n\t\t\tevent = eventType;\n\n\t\t\t// if the event dose not have a target set it to this emitter\n\t\t\tif(event.target === undefined)\n\t\t\t\tevent.target = this;\n\t\t}\n\t\telse if(isString(eventType))\n\t\t\tevent = new Event(eventType, args, this);\n\t\telse\n\t\t\tthrow new Error('Emitter.emit requires a String or Event as the first argument');\n\n\t\tlet listenerArgs = Array.from(event.args).concat([event]);\n\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\tif(\n\t\t\t\t// if they are both strings and they match\n\t\t\t\t(isString(event.type) && listenersEventType === event.type) ||\n\t\t\t\t// if the listenersEventType is a RegExp and the event type is a string, see if they match\n\t\t\t\t(isString(event.type) && isRegExp(listenersEventType) && listenersEventType.test(event.type)) ||\n\t\t\t\t// if they are both RegExp see if they match\n\t\t\t\t(isRegExp(event.type) && isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, event.type))\n\t\t\t){\n\t\t\t\tlisteners.forEach(listener => {\n\t\t\t\t\tlistener.func.apply(listener.ctx, listenerArgs);\n\t\t\t\t\tif(--listener.times <= 0)\n\t\t\t\t\t\tthis.off(event.type, listener.func, listener.ctx, true);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * removes all events of \"eventType\"\n\t * NOTE: passing no arguments will clean all listeners\n\t * NOTE: passing a single boolean will clear all listens and act as the force flag\n\t * @param {RegExp|String|Event|Boolean} [eventType] - the type of event\n\t * @param {Boolean} [force = false] - whether to force remove the listeners\n\t * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types\n\t * @return {this}\n\t */\n\tclear(eventType, force = false, useRegExp = true){\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is no event map, just exit\n\t\tif(!eventMap)\n\t\t\treturn this;\n\n\t\tif(isString(eventType)){\n\t\t\tclearListeners(eventMap, eventType, force);\n\t\t}\n\t\telse if(eventType instanceof Event){\n\t\t\tclearListeners(eventMap, eventType.type, force);\n\t\t}\n\t\telse if(isRegExp(eventType)){\n\t\t\tArray.from(eventMap).map(a => a[0]).forEach(listenersEventType => {\n\t\t\t\tif(\n\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t(isString(listenersEventType) && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t(isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t){\n\t\t\t\t\tclearListeners(eventMap, listenersEventType, force);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\telse if(arguments.length === 1 && eventType === true){\n\t\t\t// remove all listeners\n\t\t\teventMap.clear();\n\t\t}\n\t\telse if((eventType === false || eventType === undefined) && arguments.length <= 1){\n\t\t\t// remove all listeners that are not static\n\t\t\teventMap.forEach((listeners, type) => {\n\t\t\t\tlisteners.filter(listener => !listener.isStatic).forEach(listener => {\n\t\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t\t\t});\n\n\t\t\t\t// if there are no listeners left, remove the array\n\t\t\t\tif(listeners.length === 0)\n\t\t\t\t\teventMap.delete(type);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * returns the number of listeners bound to the event\n\t * @param  {RegExp|String|Event} [eventType]\n\t * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types\n\t * @return {Boolean}\n\t */\n\tcount(eventType, useRegExp = true){\n\t\tlet eventMap = this.eventMap;\n\n\t\t// if there is not event map, just exit\n\t\tif(!eventMap)\n\t\t\treturn 0;\n\n\t\tif(isString(eventType)){\n\t\t\treturn eventMap.has(eventType) ? eventMap.get(eventType).length : 0;\n\t\t}\n\t\telse if(eventType instanceof Event){\n\t\t\treturn eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;\n\t\t}\n\t\telse if(isRegExp(eventType)){\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\n\t\t\t\tif(\n\t\t\t\t\t// if the string matches the regex\n\t\t\t\t\t(isString(listenersEventType) && useRegExp && eventType.test(listenersEventType)) ||\n\t\t\t\t\t// if the regex(s) match\n\t\t\t\t\t(isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, eventType))\n\t\t\t\t){\n\t\t\t\t\ttotal += listeners.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn total;\n\t\t}\n\t\telse{\n\t\t\tlet total = 0;\n\t\t\teventMap.forEach(listeners => {\n\t\t\t\ttotal += listeners.length;\n\t\t\t});\n\t\t\treturn total;\n\t\t}\n\t}\n\n\t/**\n\t * cleans up the emitter for GC\n\t */\n\tdispose(){\n\t\tEmitter.removeEventMap(this);\n\t\treturn this;\n\t}\n}\n","import isString from 'lodash.isstring';\n\n/**\n * @classdesc the basic event class\n * @class Event\n */\nexport default class Event{\n\t/**\n\t * @param  {String} type - the type of event, this can be anything, but its a good idea just to make it a string\n\t * @param  {Emitter} target - the emitter that is firing this event\n\t * @param  {Array} args - an array of arguments that is used on the listener functions\n\t * @return {Event}\n\t */\n\tconstructor(type, args, target){\n\t\tif(!isString(type))\n\t\t\tthrow new Error('Event.type has to be a string');\n\n\t\t/**\n\t\t * the type of event\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * an array of arguments that are used when calling the listener function\n\t\t * @type {Array}\n\t\t */\n\t\tthis.args = args || [];\n\n\t\t/**\n\t\t * a reference to the emitter that fired the event\n\t\t * @type {Emitter}\n\t\t */\n\t\tthis.target = target;\n\t}\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObject(value) && objectToString.call(value) == regexpTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n"],"names":["isObjectLike","value","isString","isArray","objectToString","call","stringTag","clearListeners","eventMap","eventType","force","delete","listeners","get","filter","listener","isStatic","forEach","i","splice","indexOf","length","isRegExpEqual","r1","r2","RegExp","source","global","ignoreCase","multiline","sticky","unicode","isFunction","tag","isObject","funcTag","genTag","type","isBoolean","v","findInArgArray","args","fn","start","df","objectProto","Object","prototype","toString","Array","Event","[object Object]","target","Error","this","regexpTag","freeGlobal","freeExports","exports","nodeType","freeModule","module","freeProcess","process","nodeUtil","binding","e","nodeIsRegExp","isRegExp","func","Emitter","suppressEvents","emitter","events","WeakMap","map","Map","set","has","getEventMap","context","times","arguments","n","Number","isFinite","Infinity","o","undefined","createEventMap","push","ctx","on","listenerData","listenersEventType","event","listenerArgs","from","concat","test","apply","off","useRegExp","a","clear","total","removeEventMap"],"mappings":"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"}