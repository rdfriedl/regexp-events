{"version":3,"file":"regexp-events.es.min.js","sources":["../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isstring.js","../src/utils.js","../node_modules/lodash.isstring/index.js","../node_modules/lodash.isfunction/index.js","../src/Emitter.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/isArray.js","../src/Event.js","../node_modules/lodash.isregexp/index.js"],"sourcesContent":["var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n","export function clearListeners(eventMap, eventType, force){\r\n\tif(force) {\r\n\t\teventMap.delete(eventType);\r\n\t}\r\n\telse {\r\n\t\tlet listeners = eventMap.get(eventType);\r\n\t\tlisteners.filter(listener => !listener.isStatic).forEach((listener, i) => {\r\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\r\n\t\t});\r\n\r\n\t\t// if there are not listeners left, remove the array\r\n\t\tif(listeners.length === 0)\r\n\t\t\teventMap.delete(eventType);\r\n\t}\r\n}\r\n\r\nexport function isRegExpEqual(r1, r2){\r\n\treturn (\r\n\t\tr1 instanceof RegExp &&\r\n\t\tr2 instanceof RegExp &&\r\n\t\tr2.source === r1.source &&\r\n\t\tr2.global === r1.global &&\r\n\t\tr2.ignoreCase === r1.ignoreCase &&\r\n\t\tr2.multiline === r1.multiline &&\r\n\t\tr2.sticky === r1.sticky &&\r\n\t\tr2.unicode === r1.unicode\r\n\t);\r\n}","/**\n * lodash 4.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @type Function\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n}\n\nmodule.exports = isString;\n","/**\n * lodash 3.0.8 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8 which returns 'object' for typed array constructors, and\n  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isFunction;\n","import Event from './Event';\r\nimport {clearListeners, isRegExpEqual} from './utils';\r\nimport isString from 'lodash.isstring';\r\nimport isFunction from 'lodash.isfunction';\r\nimport isRegExp from 'lodash.isregexp';\r\n\r\nfunction isBoolean(v) {\r\n\treturn v === true || v === false;\r\n}\r\n\r\nfunction findInArgArray(args, fn, start, df) {\r\n\tfor(let i = 0; i < args.length-start; i++)\r\n\t\tif(fn(args[start+i]))\r\n\t\t\treturn args[start+i];\r\n\r\n\treturn df;\r\n}\r\n\r\n/**\r\n * a simple event emitter\r\n */\r\nexport default class Emitter{\r\n\tconstructor(){\r\n\t\t/**\r\n\t\t * whether to suppress all events on this emitter\r\n\t\t * @type {Boolean}\r\n\t\t */\r\n\t\tthis.suppressEvents = false;\r\n\t}\r\n\r\n\t/**\r\n\t * returns the Map that is used to store events for emitters\r\n\t * @param {Emitter} emitter\r\n\t * @return {WeakMap}\r\n\t */\r\n\tstatic getEventMap(emitter){\r\n\t\tlet map = this.events || (this.events = new WeakMap());\r\n\t\treturn map.get(emitter);\r\n\t}\r\n\r\n\t/**\r\n\t * creates a new Map for the emitter\r\n\t * @param {Emitter} emitter\r\n\t * @return {Map}\r\n\t */\r\n\tstatic createEventMap(emitter){\r\n\t\tlet map = this.events || (this.events = new WeakMap());\r\n\t\tlet events = new Map();\r\n\t\tmap.set(emitter, events);\r\n\t\treturn events;\r\n\t}\r\n\r\n\t/**\r\n\t * creates a new Map for the emitter\r\n\t * @param {Emitter} emitter\r\n\t * @return {Map}\r\n\t */\r\n\tstatic removeEventMap(emitter){\r\n\t\tlet map = this.events || (this.events = new WeakMap());\r\n\t\tif(map.has(emitter))\r\n\t\t\tmap.delete(emitter);\r\n\t}\r\n\r\n\t/**\r\n\t * returns the Map used to store events\r\n\t * @return {Map}\r\n\t */\r\n\tget eventMap() {\r\n\t\treturn Emitter.getEventMap(this);\r\n\t}\r\n\r\n\t/**\r\n\t * listens for an event of this emitter\r\n\t * @param  {RegExp|String|Event} eventType\r\n\t * @param  {Function} listener - the function to be called when the event fires\r\n\t * @param  {Object|Boolean|Number} [context] - the context to run the function under\r\n\t * @param  {Boolean|Number|Object} [isStatic=true] - whether this listener can be removed without force\r\n\t * @param  {Number|Boolean|Object} [times=Infinity] the times this listener can be called before it removes it self\r\n\t * @return {this}\r\n\t */\r\n\ton(eventType, listener, context, isStatic, times){\r\n\t\tif(!isString(eventType) && !isRegExp(eventType) && !(eventType instanceof Event))\r\n\t\t\tthrow new Error('Emitter.on requires a String, Event or RegExp as the first argument');\r\n\r\n\t\tif(!isFunction(listener))\r\n\t\t\tthrow new Error('Emitter.on requires a function as the second argument');\r\n\r\n\t\tisStatic = findInArgArray(arguments, isBoolean, 2, false);\r\n\t\ttimes = findInArgArray(arguments, n => Number.isFinite(n) || n === Infinity, 2, Infinity);\r\n\t\tcontext = findInArgArray(arguments, o => {\r\n\t\t\tconsole.log(typeof o);\r\n\t\t\treturn typeof o === 'object';\r\n\t\t}, 2, undefined);\r\n\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tif(!eventMap)\r\n\t\t\teventMap = Emitter.createEventMap(this);\r\n\r\n\t\tif(eventType instanceof Event)\r\n\t\t\teventType = eventType.type;\r\n\r\n\t\tif(!eventMap.has(eventType))\r\n\t\t\teventMap.set(eventType, []);\r\n\r\n\t\t// add the listener to the array\r\n\t\teventMap.get(eventType).push({\r\n\t\t\tfunc: listener,\r\n\t\t\tctx: context,\r\n\t\t\ttimes: times,\r\n\t\t\tisStatic: isStatic\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * binds a listener that removes its self once the event is fired\r\n\t * @param  {RegExp|String|Event} eventType\r\n\t * @param  {Function} listener\r\n\t * @param  {Object|Boolean} [context] - the context to run the functions under\r\n\t * @param  {Boolean|Object} [isStatic = false] - whether this listener can be removed without using force\r\n\t * @return {this}\r\n\t */\r\n\tonce(eventType, listener, context, isStatic){\r\n\t\treturn this.on(eventType, listener, 1, context, isStatic);\r\n\t}\r\n\r\n\t/**\r\n\t * removes a listener\r\n\t * @param  {RegExp|String|Event} eventType\r\n\t * @param  {Function} listener - this has to be the exact function that was bound\r\n\t * @param  {*|Boolean} [context] - this has to be the exact context that was bound with the listener\r\n\t * @param  {Boolean} [force=false] - whether to force remove the listeners\r\n\t * @return {this}\r\n\t */\r\n\toff(eventType, listener, context, force){\r\n\t\tif(eventType == null)\r\n\t\t\tthrow new Error('Emitter.off requires a String or a RegExp as the first argument');\r\n\r\n\t\tif(!isFunction(listener))\r\n\t\t\tthrow new Error('Emitter.off requires a function as the second argument');\r\n\r\n\t\tforce = findInArgArray(arguments, isBoolean, 2, false);\r\n\t\tcontext = findInArgArray(arguments, o => typeof o === 'object', 2, undefined);\r\n\r\n\t\tif(eventType instanceof Event)\r\n\t\t\teventType = eventType.type;\r\n\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tif(!eventMap)\r\n\t\t\treturn this; // if there is not event map, just exit\r\n\r\n\t\tif(!eventMap.has(eventType))\r\n\t\t\teventMap.set(eventType, []);\r\n\r\n\t\tif(isString(eventType)){\r\n\t\t\tlet listeners = eventMap.get(eventType);\r\n\t\t\tlisteners.forEach((listenerData, i) => {\r\n\t\t\t\tif(listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic? force : true))\r\n\t\t\t\t\tlisteners.splice(i,1);\r\n\t\t\t});\r\n\r\n\t\t\t// remove the listener array if there are no listeners left\r\n\t\t\tif(listeners.length === 0)\r\n\t\t\t\teventMap.delete(eventType);\r\n\t\t}\r\n\t\telse if(isRegExp(eventType)){\r\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\r\n\t\t\t\t// if the regexp flags and source match then remove the listeners\r\n\t\t\t\tif(isRegExp(listenersEventType) && isRegExpEqual(eventType, listenersEventType)){\r\n\t\t\t\t\tlisteners.forEach((listenerData, i) => {\r\n\t\t\t\t\t\tif(listenerData.func === listener && listenerData.ctx === context && (listenerData.isStatic? force : true))\r\n\t\t\t\t\t\t\tlisteners.splice(i,1);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// remove the listener array if there are no listeners left\r\n\t\t\t\t\tif(listeners.length === 0)\r\n\t\t\t\t\t\teventMap.delete(listenersEventType);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * fires ad event on this emitter\r\n\t * @param {String|Event} eventType\r\n\t * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in\r\n\t * @return {this}\r\n\t */\r\n\temit(eventType, ...args){\r\n\t\tif(this.suppressEvents) return;\r\n\t\tlet eventMap = this.eventMap;\r\n\t\tlet event;\r\n\r\n\t\t// if there is not event map, just exit\r\n\t\tif(!eventMap)\r\n\t\t\treturn this;\r\n\r\n\t\t// if its an event use the events type\r\n\t\tif(eventType instanceof Event){\r\n\t\t\tevent = eventType;\r\n\r\n\t\t\t// if the event dose not have a target set it to this emitter\r\n\t\t\tif(event.target === undefined)\r\n\t\t\t\tevent.target = this;\r\n\t\t}\r\n\t\telse if(isString(eventType))\r\n\t\t\tevent = new Event(eventType, args, this);\r\n\t\telse\r\n\t\t\tthrow new Error('Emitter.emit requires a String or Event as the first argument');\r\n\r\n\t\tlet listenerArgs = Array.from(event.args).concat([event]);\r\n\t\teventMap.forEach((listeners, listenersEventType) => {\r\n\t\t\tif(\r\n\t\t\t\t// if they are both strings and they match\r\n\t\t\t\t(isString(event.type) && listenersEventType === event.type) ||\r\n\t\t\t\t// if the listenersEventType is a RegExp and the event type is a string, see if they match\r\n\t\t\t\t(isString(event.type) && isRegExp(listenersEventType) && listenersEventType.test(event.type)) ||\r\n\t\t\t\t// if they are both RegExp see if they match\r\n\t\t\t\t(isRegExp(event.type) && isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, event.type))\r\n\t\t\t){\r\n\t\t\t\tlisteners.forEach(listener => {\r\n\t\t\t\t\tlistener.func.apply(listener.ctx, listenerArgs);\r\n\t\t\t\t\tif(--listener.times <= 0)\r\n\t\t\t\t\t\tthis.off(event.type, listener.func, listener.ctx, true);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * removes all events of \"eventType\"\r\n\t * NOTE: passing no arguments will clean all listeners\r\n\t * NOTE: passing a single boolean will clear all listens and act as the force flag\r\n\t * @param {RegExp|String|Event|Boolean} [eventType] - the type of event\r\n\t * @param {Boolean} [force = false] - whether to force remove the listeners\r\n\t * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types\r\n\t * @return {this}\r\n\t */\r\n\tclear(eventType, force = false, useRegExp = true){\r\n\t\tlet eventMap = this.eventMap;\r\n\r\n\t\t// if there is no event map, just exit\r\n\t\tif(!eventMap)\r\n\t\t\treturn this;\r\n\r\n\t\tif(isString(eventType)){\r\n\t\t\tclearListeners(eventMap, eventType, force);\r\n\t\t}\r\n\t\telse if(eventType instanceof Event){\r\n\t\t\tclearListeners(eventMap, eventType.type, force);\r\n\t\t}\r\n\t\telse if(isRegExp(eventType)){\r\n\t\t\tArray.from(eventMap).map(a => a[0]).forEach(listenersEventType => {\r\n\t\t\t\tif(\r\n\t\t\t\t\t// if the string matches the regex\r\n\t\t\t\t\t(isString(listenersEventType) && useRegExp && eventType.test(listenersEventType)) ||\r\n\t\t\t\t\t// if the regex(s) match\r\n\t\t\t\t\t(isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, eventType))\r\n\t\t\t\t){\r\n\t\t\t\t\tclearListeners(eventMap, listenersEventType, force);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\telse if(arguments.length === 1 && eventType === true){\r\n\t\t\t// remove all listeners\r\n\t\t\teventMap.clear();\r\n\t\t}\r\n\t\telse if((eventType === false || eventType === undefined) && arguments.length <= 1){\r\n\t\t\t// remove all listeners that are not static\r\n\t\t\teventMap.forEach((listeners, type) => {\r\n\t\t\t\tlisteners.filter(listener => !listener.isStatic).forEach(listener => {\r\n\t\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// if there are no listeners left, remove the array\r\n\t\t\t\tif(listeners.length === 0)\r\n\t\t\t\t\teventMap.delete(type);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * returns the number of listeners bound to the event\r\n\t * @param  {RegExp|String|Event} [eventType]\r\n\t * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types\r\n\t * @return {Boolean}\r\n\t */\r\n\tcount(eventType, useRegExp = true){\r\n\t\tlet eventMap = this.eventMap;\r\n\r\n\t\t// if there is not event map, just exit\r\n\t\tif(!eventMap)\r\n\t\t\treturn 0;\r\n\r\n\t\tif(isString(eventType)){\r\n\t\t\treturn eventMap.has(eventType) ? eventMap.get(eventType).length : 0;\r\n\t\t}\r\n\t\telse if(eventType instanceof Event){\r\n\t\t\treturn eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;\r\n\t\t}\r\n\t\telse if(isRegExp(eventType)){\r\n\t\t\tlet total = 0;\r\n\t\t\teventMap.forEach((listeners, listenersEventType) => {\r\n\t\t\t\tif(\r\n\t\t\t\t\t// if the string matches the regex\r\n\t\t\t\t\t(isString(listenersEventType) && useRegExp && eventType.test(listenersEventType)) ||\r\n\t\t\t\t\t// if the regex(s) match\r\n\t\t\t\t\t(isRegExp(listenersEventType) && isRegExpEqual(listenersEventType, eventType))\r\n\t\t\t\t){\r\n\t\t\t\t\ttotal += listeners.length;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn total;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tlet total = 0;\r\n\t\t\teventMap.forEach(listeners => {\r\n\t\t\t\ttotal += listeners.length;\r\n\t\t\t});\r\n\t\t\treturn total;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * cleans up the emitter for GC\r\n\t */\r\n\tdispose(){\r\n\t\tEmitter.removeEventMap(this);\r\n\t\treturn this;\r\n\t}\r\n}\r\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","import isString from 'lodash/isstring';\r\n\r\n/**\r\n * @classdesc the basic event class\r\n * @class Event\r\n */\r\nexport default class Event{\r\n\t/**\r\n\t * @param  {String} type - the type of event, this can be anything, but its a good idea just to make it a string\r\n\t * @param  {Emitter} target - the emitter that is firing this event\r\n\t * @param  {Array} args - an array of arguments that is used on the listener functions\r\n\t * @return {Event}\r\n\t */\r\n\tconstructor(type, args, target){\r\n\t\tif(!isString(type))\r\n\t\t\tthrow new Error('Event.type has to be a string');\r\n\r\n\t\t/**\r\n\t\t * the type of event\r\n\t\t * @type {String}\r\n\t\t */\r\n\t\tthis.type = type;\r\n\r\n\t\t/**\r\n\t\t * an array of arguments that are used when calling the listener function\r\n\t\t * @type {Array}\r\n\t\t */\r\n\t\tthis.args = args || [];\r\n\r\n\t\t/**\r\n\t\t * a reference to the emitter that fired the event\r\n\t\t * @type {Emitter}\r\n\t\t */\r\n\t\tthis.target = target;\r\n\t}\r\n}\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObject(value) && objectToString.call(value) == regexpTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n"],"names":["getRawTag","value","isOwn","hasOwnProperty","call","symToStringTag","tag","undefined","e","result","nativeObjectToString","objectToString","baseGetTag","undefinedTag","nullTag","Object","isObjectLike","isString","isArray","stringTag","clearListeners","eventMap","eventType","force","delete","listeners","get","filter","listener","isStatic","forEach","i","splice","indexOf","length","isRegExpEqual","r1","r2","RegExp","source","global","ignoreCase","multiline","sticky","unicode","isFunction","isObject","funcTag","genTag","type","isBoolean","v","findInArgArray","args","fn","start","df","freeGlobal","freeSelf","self","root","Function","Symbol","objectProto","prototype","toString","toStringTag","Array","Event","[object Object]","target","Error","this","baseIsRegExp","regexpTag","freeExports","exports","nodeType","freeModule","module","moduleExports","freeProcess","process","nodeUtil","binding","nodeIsRegExp","isRegExp","func","Emitter","suppressEvents","emitter","events","WeakMap","map","Map","set","has","getEventMap","context","times","arguments","n","Number","isFinite","Infinity","o","console","log","createEventMap","push","ctx","on","listenerData","listenersEventType","event","listenerArgs","from","concat","test","apply","off","useRegExp","a","clear","total","removeEventMap"],"mappings":"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"}