<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/Emitter.js | RegExp Events</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A simple RegExp event emitter"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="RegExp Events"><meta property="twitter:description" content="A simple RegExp event emitter"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/rdfriedl/regexp-events"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Emitter.js~Emitter.html">Emitter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Event.js~Event.html">Event</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-clearListeners">clearListeners</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isRegExpEqual">isRegExpEqual</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Emitter.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Event from &quot;./Event&quot;;
import { clearListeners, isRegExpEqual } from &quot;./utils&quot;;

function isBoolean(v) {
	return v === true || v === false;
}

function findInArgArray(args, fn, start, df) {
	for (let i = 0; i &lt; args.length - start; i++) if (fn(args[start + i])) return args[start + i];

	return df;
}

/**
 * a simple event emitter
 */
export default class Emitter {
	constructor() {
		/**
		 * whether to suppress all events on this emitter
		 * @type {Boolean}
		 */
		this.suppressEvents = false;
	}

	/**
	 * returns the Map that is used to store events for emitters
	 * @param {Emitter} emitter
	 * @return {WeakMap}
	 */
	static getEventMap(emitter) {
		let map = this.events || (this.events = new WeakMap());
		return map.get(emitter);
	}

	/**
	 * creates a new Map for the emitter
	 * @param {Emitter} emitter
	 * @return {Map}
	 */
	static createEventMap(emitter) {
		let map = this.events || (this.events = new WeakMap());
		let events = new Map();
		map.set(emitter, events);
		return events;
	}

	/**
	 * creates a new Map for the emitter
	 * @param {Emitter} emitter
	 * @return {Map}
	 */
	static removeEventMap(emitter) {
		let map = this.events || (this.events = new WeakMap());
		if (map.has(emitter)) map.delete(emitter);
	}

	/**
	 * returns the Map used to store events
	 * @return {Map}
	 */
	get eventMap() {
		return Emitter.getEventMap(this);
	}

	/**
	 * listens for an event of this emitter
	 * @param  {RegExp|String|Event} eventType
	 * @param  {Function} listener - the function to be called when the event fires
	 * @param  {Object|Boolean|Number} [context] - the context to run the function under
	 * @param  {Boolean|Number|Object} [isStatic=true] - whether this listener can be removed without force
	 * @param  {Number|Boolean|Object} [times=Infinity] the times this listener can be called before it removes it self
	 * @return {this}
	 */
	on(eventType, listener, context, isStatic, times) {
		if (typeof eventType !== &quot;string&quot; &amp;&amp; !(eventType instanceof RegExp) &amp;&amp; !(eventType instanceof Event))
			throw new Error(&quot;Emitter.on requires a String, Event or RegExp as the first argument&quot;);

		if (typeof listener !== &quot;function&quot;) throw new Error(&quot;Emitter.on requires a function as the second argument&quot;);

		isStatic = findInArgArray(arguments, isBoolean, 2, false);
		times = findInArgArray(arguments, n =&gt; Number.isFinite(n) || n === Infinity, 2, Infinity);
		context = findInArgArray(
			arguments,
			o =&gt; {
				return typeof o === &quot;object&quot;;
			},
			2,
			undefined,
		);

		let eventMap = this.eventMap;
		if (!eventMap) eventMap = Emitter.createEventMap(this);

		if (eventType instanceof Event) eventType = eventType.type;

		if (!eventMap.has(eventType)) eventMap.set(eventType, []);

		// add the listener to the array
		eventMap.get(eventType).push({
			func: listener,
			ctx: context,
			times: times,
			isStatic: isStatic,
		});
		return this;
	}

	/**
	 * binds a listener that removes its self once the event is fired
	 * @param  {RegExp|String|Event} eventType
	 * @param  {Function} listener
	 * @param  {Object|Boolean} [context] - the context to run the functions under
	 * @param  {Boolean|Object} [isStatic = false] - whether this listener can be removed without using force
	 * @return {this}
	 */
	once(eventType, listener, context, isStatic) {
		return this.on(eventType, listener, 1, context, isStatic);
	}

	/**
	 * removes a listener
	 * @param  {RegExp|String|Event} eventType
	 * @param  {Function} listener - this has to be the exact function that was bound
	 * @param  {*|Boolean} [context] - this has to be the exact context that was bound with the listener
	 * @param  {Boolean} [force=false] - whether to force remove the listeners
	 * @return {this}
	 */
	off(eventType, listener, context, force) {
		if (eventType == null) throw new Error(&quot;Emitter.off requires a String or a RegExp as the first argument&quot;);

		if (typeof listener !== &quot;function&quot;) throw new Error(&quot;Emitter.off requires a function as the second argument&quot;);

		force = findInArgArray(arguments, isBoolean, 2, false);
		context = findInArgArray(arguments, o =&gt; typeof o === &quot;object&quot;, 2, undefined);

		if (eventType instanceof Event) eventType = eventType.type;

		let eventMap = this.eventMap;
		if (!eventMap) return this; // if there is not event map, just exit

		if (!eventMap.has(eventType)) eventMap.set(eventType, []);

		if (typeof eventType === &quot;string&quot;) {
			let listeners = eventMap.get(eventType);
			listeners.forEach((listenerData, i) =&gt; {
				if (listenerData.func === listener &amp;&amp; listenerData.ctx === context &amp;&amp; (listenerData.isStatic ? force : true))
					listeners.splice(i, 1);
			});

			// remove the listener array if there are no listeners left
			if (listeners.length === 0) eventMap.delete(eventType);
		} else if (eventType instanceof RegExp) {
			eventMap.forEach((listeners, listenersEventType) =&gt; {
				// if the regexp flags and source match then remove the listeners
				if (listenersEventType instanceof RegExp &amp;&amp; isRegExpEqual(eventType, listenersEventType)) {
					listeners.forEach((listenerData, i) =&gt; {
						if (
							listenerData.func === listener &amp;&amp;
							listenerData.ctx === context &amp;&amp;
							(listenerData.isStatic ? force : true)
						)
							listeners.splice(i, 1);
					});

					// remove the listener array if there are no listeners left
					if (listeners.length === 0) eventMap.delete(listenersEventType);
				}
			});
		}

		return this;
	}

	/**
	 * fires ad event on this emitter
	 * @param {String|Event} eventType
	 * @param {...*} args - the arguments to be passed to the listeners. these will be ignored if an Event was passed in
	 * @return {this}
	 */
	emit(eventType, ...args) {
		if (this.suppressEvents) return;
		let eventMap = this.eventMap;
		let event;

		// if there is not event map, just exit
		if (!eventMap) return this;

		// if its an event use the events type
		if (eventType instanceof Event) {
			event = eventType;

			// if the event dose not have a target set it to this emitter
			if (event.target === undefined) event.target = this;
		} else if (typeof eventType === &quot;string&quot;) event = new Event(eventType, args, this);
		else throw new Error(&quot;Emitter.emit requires a String or Event as the first argument&quot;);

		let listenerArgs = Array.from(event.args).concat([event]);
		eventMap.forEach((listeners, listenersEventType) =&gt; {
			if (
				// if they are both strings and they match
				(typeof event.type === &quot;string&quot; &amp;&amp; listenersEventType === event.type) ||
				// if the listenersEventType is a RegExp and the event type is a string, see if they match
				(typeof event.type === &quot;string&quot; &amp;&amp;
					listenersEventType instanceof RegExp &amp;&amp;
					listenersEventType.test(event.type)) ||
				// if they are both RegExp see if they match
				(event.type instanceof RegExp &amp;&amp;
					listenersEventType instanceof RegExp &amp;&amp;
					isRegExpEqual(listenersEventType, event.type))
			) {
				listeners.forEach(listener =&gt; {
					listener.func.apply(listener.ctx, listenerArgs);
					if (--listener.times &lt;= 0) this.off(event.type, listener.func, listener.ctx, true);
				});
			}
		});

		return this;
	}

	/**
	 * removes all events of &quot;eventType&quot;
	 * NOTE: passing no arguments will clean all listeners
	 * NOTE: passing a single boolean will clear all listens and act as the force flag
	 * @param {RegExp|String|Event|Boolean} [eventType] - the type of event
	 * @param {Boolean} [force = false] - whether to force remove the listeners
	 * @param {Boolean} [useRegExp = true] - whether to use the RegExp to test other types
	 * @return {this}
	 */
	clear(eventType, force = false, useRegExp = true) {
		let eventMap = this.eventMap;

		// if there is no event map, just exit
		if (!eventMap) return this;

		if (typeof eventType === &quot;string&quot;) {
			clearListeners(eventMap, eventType, force);
		} else if (eventType instanceof Event) {
			clearListeners(eventMap, eventType.type, force);
		} else if (eventType instanceof RegExp) {
			Array.from(eventMap)
				.map(a =&gt; a[0])
				.forEach(listenersEventType =&gt; {
					if (
						// if the string matches the regex
						(typeof listenersEventType === &quot;string&quot; &amp;&amp; useRegExp &amp;&amp; eventType.test(listenersEventType)) ||
						// if the regex(s) match
						(listenersEventType instanceof RegExp &amp;&amp; isRegExpEqual(listenersEventType, eventType))
					) {
						clearListeners(eventMap, listenersEventType, force);
					}
				});
		} else if (arguments.length === 1 &amp;&amp; eventType === true) {
			// remove all listeners
			eventMap.clear();
		} else if ((eventType === false || eventType === undefined) &amp;&amp; arguments.length &lt;= 1) {
			// remove all listeners that are not static
			eventMap.forEach((listeners, type) =&gt; {
				listeners.filter(listener =&gt; !listener.isStatic).forEach(listener =&gt; {
					listeners.splice(listeners.indexOf(listener), 1);
				});

				// if there are no listeners left, remove the array
				if (listeners.length === 0) eventMap.delete(type);
			});
		}

		return this;
	}

	/**
	 * returns the number of listeners bound to the event
	 * @param  {RegExp|String|Event} [eventType]
	 * @param {Boolean} [useRegExp] - whether to use the RegExp to test other types
	 * @return {Boolean}
	 */
	count(eventType, useRegExp = true) {
		let eventMap = this.eventMap;

		// if there is not event map, just exit
		if (!eventMap) return 0;

		if (typeof eventType === &quot;string&quot;) {
			return eventMap.has(eventType) ? eventMap.get(eventType).length : 0;
		} else if (eventType instanceof Event) {
			return eventMap.has(eventType.type) ? eventMap.get(eventType.type).length : 0;
		} else if (eventType instanceof RegExp) {
			let total = 0;
			eventMap.forEach((listeners, listenersEventType) =&gt; {
				if (
					// if the string matches the regex
					(typeof listenersEventType === &quot;string&quot; &amp;&amp; useRegExp &amp;&amp; eventType.test(listenersEventType)) ||
					// if the regex(s) match
					(listenersEventType instanceof RegExp &amp;&amp; isRegExpEqual(listenersEventType, eventType))
				) {
					total += listeners.length;
				}
			});
			return total;
		} else {
			let total = 0;
			eventMap.forEach(listeners =&gt; {
				total += listeners.length;
			});
			return total;
		}
	}

	/**
	 * cleans up the emitter for GC
	 */
	dispose() {
		Emitter.removeEventMap(this);
		return this;
	}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
